<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craftverse Server</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            height: 100vh;
        }
        #game-canvas {
            flex: 2;
            background: #87CEEB;
        }
        #ui-container {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            overflow-y: auto;
        }
        h1 {
            color: #2c3e50;
        }
        p {
            color: #34495e;
            line-height: 1.6;
        }
        #players {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        #chat {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        .player {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            min-width: 150px;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .connected {
            background: #d4edda;
            color: #155724;
        }
        .disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        #controls {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .control-btn {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        .control-btn:hover {
            background: #0056b3;
        }
        .control-btn.active {
            background: #28a745;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        .chat-message {
            text-align: left;
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .system-message {
            background: #e9ecef;
            color: #6c757d;
        }
        .player-message {
            background: #e3f2fd;
            color: #1976d2;
        }
        #chat-input {
            display: flex;
            gap: 10px;
        }
        #message-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        #send-message {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #send-message:hover {
            background: #218838;
        }
        #inventory {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .inventory-slot {
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }
        .inventory-slot.selected {
            background: #007bff;
            color: white;
        }
        .inventory-slot img {
            width: 32px;
            height: 32px;
        }
        .block-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
        }
        #block-info {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .movement-mode {
            margin-top: 10px;
            padding: 5px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .movement-mode button {
            margin: 0 5px;
            padding: 5px 10px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .movement-mode button.active {
            background: #28a745;
        }

        /* Block breaking animation */
        .block-breaking {
            position: relative;
            overflow: hidden;
        }
        .block-breaking::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            animation: breaking 1s linear forwards;
        }
        @keyframes breaking {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Player animations */
        .player {
            transition: transform 0.2s ease;
        }
        .player.walking {
            animation: walk 0.5s infinite;
        }
        .player.running {
            animation: run 0.3s infinite;
        }
        .player.crouching {
            transform: scale(0.8);
        }
        .player.jumping {
            animation: jump 0.5s ease;
        }
        @keyframes walk {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        @keyframes run {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        @keyframes jump {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        /* Block preview */
        .block-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 64px;
            height: 64px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            pointer-events: none;
            display: none;
        }
        .block-preview.visible {
            display: block;
        }

        /* Block breaking progress */
        .breaking-progress {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            display: none;
        }
        .breaking-progress.visible {
            display: block;
        }
        .breaking-progress-bar {
            width: 0%;
            height: 100%;
            background: #28a745;
            border-radius: 10px;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
            <h1>Welcome to Craftverse Server</h1>
            <div id="status" class="disconnected">
                Status: Disconnected
            </div>

            <div id="players">
                <h2>Connected Players</h2>
                <div id="playerList"></div>
            </div>

            <div id="chat">
                <h2>Chat</h2>
                <div id="chat-messages"></div>
                <div id="chat-input">
                    <input type="text" id="message-input" placeholder="Type a message...">
                    <button id="send-message">Send</button>
                </div>
            </div>

            <div id="controls">
                <h2>Movement Controls</h2>
                <div class="movement-mode">
                    <button id="walk-mode" class="active">Walk</button>
                    <button id="run-mode">Run</button>
                    <button id="crouch-mode">Crouch</button>
                </div>
                <button class="control-btn" id="move-forward">Forward</button>
                <button class="control-btn" id="move-backward">Backward</button>
                <button class="control-btn" id="move-left">Left</button>
                <button class="control-btn" id="move-right">Right</button>
                <button class="control-btn" id="jump">Jump</button>
            </div>

            <div id="inventory">
                <h2>Inventory</h2>
                <div class="inventory-grid" id="inventory-grid"></div>
                <div id="block-info">
                    <p>Selected Block: <span id="selected-block">None</span></p>
                    <p>Block Count: <span id="block-count">0</span></p>
                </div>
            </div>
        </div>
    </div>

    <div class="block-preview" id="block-preview"></div>
    <div class="breaking-progress" id="breaking-progress">
        <div class="breaking-progress-bar"></div>
    </div>

    <script>
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('game-canvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth * 0.66, window.innerHeight);
        renderer.shadowMap.enabled = true;

        // Add skybox
        const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const skyboxMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
        scene.add(skybox);

        // Add sun
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(50, 50, 50);
        scene.add(sun);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Add ground plane
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a9d23,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Block materials
        const blockMaterials = {
            grass: new THREE.MeshStandardMaterial({ color: 0x3a9d23 }),
            dirt: new THREE.MeshStandardMaterial({ color: 0x8b4513 }),
            stone: new THREE.MeshStandardMaterial({ color: 0x808080 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8b4513 }),
            leaves: new THREE.MeshStandardMaterial({ color: 0x2d5a27 }),
            sand: new THREE.MeshStandardMaterial({ color: 0xc2b280 }),
            water: new THREE.MeshStandardMaterial({ 
                color: 0x0077be,
                transparent: true,
                opacity: 0.6
            }),
            lava: new THREE.MeshStandardMaterial({ color: 0xff4500 }),
            glass: new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            }),
            brick: new THREE.MeshStandardMaterial({ color: 0xb22222 })
        };

        // Block geometries
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let blockMeshes = {};

        // Camera position
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        // Mouse controls
        let isPointerLocked = false;
        const moveSpeed = 0.1;
        const keys = {};

        // Add raycaster for block interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        document.addEventListener('click', (event) => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
            } else {
                // Calculate mouse position in normalized device coordinates
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Update raycaster
                raycaster.setFromCamera(mouse, camera);

                // Find intersected blocks
                const intersects = raycaster.intersectObjects(scene.children);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const position = intersect.object.position;
                    const positionKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;
                    
                    if (selectedBlock) {
                        // Place block
                        const newBlocks = { ...initialBlocks };
                        newBlocks[positionKey] = { type: selectedBlock };
                        updateWorld(newBlocks);
                    } else {
                        // Remove block
                        const newBlocks = { ...initialBlocks };
                        delete newBlocks[positionKey];
                        updateWorld(newBlocks);
                    }
                }
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            } else {
                // Update block preview
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                
                if (intersects.length > 0 && selectedBlock) {
                    const intersect = intersects[0];
                    const position = intersect.object.position;
                    const positionKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;
                    updateBlockPreview(positionKey);
                } else {
                    hideBlockPreview();
                }
            }
        });

        // Update world
        function updateWorld(blocks) {
            // Remove old blocks
            Object.values(blockMeshes).forEach(mesh => {
                scene.remove(mesh);
            });
            blockMeshes = {};

            // Add new blocks
            Object.entries(blocks).forEach(([position, block]) => {
                const [x, y, z] = position.split(',').map(Number);
                const mesh = new THREE.Mesh(blockGeometry, blockMaterials[block.type]);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                blockMeshes[position] = mesh;
            });
        }

        // Set initial player state
        let currentPlayer = {
            id: 'local-player',
            position: { x: 0, y: 2, z: 5 },
            health: 100,
            inventory: {
                grass: 64,
                dirt: 64,
                stone: 64,
                wood: 64,
                leaves: 64,
                sand: 64
            }
        };

        // Player idle animation
        let idleTime = 0;
        const idleAnimation = () => {
            idleTime += 0.02;
            if (!keys['KeyW'] && !keys['KeyS'] && !keys['KeyA'] && !keys['KeyD']) {
                const playerElement = document.getElementById(`player-${currentPlayer.id}`);
                if (playerElement) {
                    playerElement.style.transform = `translateY(${Math.sin(idleTime) * 2}px)`;
                }
            }
        };

        // Update animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (isPointerLocked) {
                const moveSpeed = movementMode === 'run' ? 0.2 : movementMode === 'crouch' ? 0.05 : 0.1;
                
                if (keys['KeyW']) {
                    camera.translateZ(-moveSpeed);
                }
                if (keys['KeyS']) {
                    camera.translateZ(moveSpeed);
                }
                if (keys['KeyA']) {
                    camera.translateX(-moveSpeed);
                }
                if (keys['KeyD']) {
                    camera.translateX(moveSpeed);
                }
                if (keys['Space']) {
                    camera.position.y += 0.1;
                }
            }

            // Update sun position
            sun.position.x = Math.cos(Date.now() * 0.0001) * 50;
            sun.position.z = Math.sin(Date.now() * 0.0001) * 50;
            directionalLight.position.copy(sun.position);

            // Update idle animation
            idleAnimation();

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.66, window.innerHeight);
        });

        // Start animation
        animate();

        const socket = {
            emit: () => {},
            on: () => {}
        };

        const playerList = document.getElementById('playerList');
        const status = document.getElementById('status');
        const chatMessages = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message-input');
        const sendMessageBtn = document.getElementById('send-message');
        const inventoryGrid = document.getElementById('inventory-grid');
        const selectedBlockSpan = document.getElementById('selected-block');
        const blockCountSpan = document.getElementById('block-count');
        let selectedBlock = null;
        let movementMode = 'walk';
        let movementSpeed = 1;

        // Extended block types
        const blockTypes = {
            grass: { name: 'Grass', image: '🌱', hardness: 1 },
            dirt: { name: 'Dirt', image: '🟫', hardness: 1 },
            stone: { name: 'Stone', image: '🪨', hardness: 2 },
            wood: { name: 'Wood', image: '🪵', hardness: 1.5 },
            leaves: { name: 'Leaves', image: '🍃', hardness: 0.5 },
            sand: { name: 'Sand', image: '🏖️', hardness: 1 },
            water: { name: 'Water', image: '💧', hardness: 0 },
            lava: { name: 'Lava', image: '🌋', hardness: 0 },
            glass: { name: 'Glass', image: '🪟', hardness: 1 },
            brick: { name: 'Brick', image: '🧱', hardness: 2 }
        };

        // Movement controls
        const controls = {
            'move-forward': { x: 0, z: -1 },
            'move-backward': { x: 0, z: 1 },
            'move-left': { x: -1, z: 0 },
            'move-right': { x: 1, z: 0 },
            'jump': { y: 1 }
        };

        // Block breaking state
        let breakingBlock = null;
        let breakingProgress = 0;
        let breakingInterval = null;

        // Movement mode buttons
        document.getElementById('walk-mode').addEventListener('click', () => setMovementMode('walk'));
        document.getElementById('run-mode').addEventListener('click', () => setMovementMode('run'));
        document.getElementById('crouch-mode').addEventListener('click', () => setMovementMode('crouch'));

        function setMovementMode(mode) {
            movementMode = mode;
            movementSpeed = mode === 'run' ? 2 : mode === 'crouch' ? 0.5 : 1;
            
            // Update button styles
            document.querySelectorAll('.movement-mode button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${mode}-mode`).classList.add('active');

            // Update player animation
            if (currentPlayer) {
                const playerElement = document.getElementById(`player-${currentPlayer.id}`);
                if (playerElement) {
                    playerElement.classList.remove('walking', 'running', 'crouching');
                    playerElement.classList.add(mode === 'run' ? 'running' : mode === 'crouch' ? 'crouching' : 'walking');
                }
            }
        }

        Object.entries(controls).forEach(([id, movement]) => {
            document.getElementById(id).addEventListener('click', () => {
                if (currentPlayer) {
                    socket.emit('playerMove', {
                        id: currentPlayer.id,
                        position: {
                            x: currentPlayer.position.x + movement.x * movementSpeed,
                            y: currentPlayer.position.y + (movement.y || 0),
                            z: currentPlayer.position.z + movement.z * movementSpeed
                        }
                    });
                }
            });
        });

        // Initialize inventory
        function initializeInventory() {
            inventoryGrid.innerHTML = '';
            Object.entries(blockTypes).forEach(([type, block]) => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.dataset.type = type;
                slot.innerHTML = `
                    <div>${block.image}</div>
                    <div class="block-count">0</div>
                `;
                slot.addEventListener('click', () => selectBlock(type));
                inventoryGrid.appendChild(slot);
            });
        }

        function selectBlock(type) {
            selectedBlock = type;
            selectedBlockSpan.textContent = blockTypes[type].name;
            document.querySelectorAll('.inventory-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');
        }

        // Chat functionality
        sendMessageBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        function sendMessage() {
            const message = messageInput.value.trim();
            if (message && currentPlayer) {
                socket.emit('chatMessage', {
                    playerId: currentPlayer.id,
                    message: message
                });
                messageInput.value = '';
            }
        }

        function addChatMessage(message, type = 'player-message') {
            const messageElement = document.createElement('div');
            messageElement.className = `chat-message ${type}`;
            messageElement.textContent = message;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        socket.on('connect', () => {
            status.textContent = 'Status: Connected';
            status.className = 'connected';
            addChatMessage('Connected to server', 'system-message');
            initializeInventory();
        });

        socket.on('disconnect', () => {
            status.textContent = 'Status: Disconnected';
            status.className = 'disconnected';
            addChatMessage('Disconnected from server', 'system-message');
        });

        socket.on('gameState', (state) => {
            updatePlayerList(state.players);
            if (state.players[socket.id]) {
                currentPlayer = state.players[socket.id];
                updateInventory(state.players[socket.id].inventory);
            }
            updateWorld(state.blocks);
        });

        socket.on('playerJoin', (player) => {
            addPlayer(player);
            addChatMessage(`Player ${player.id.slice(0, 6)} joined the game`, 'system-message');
        });

        socket.on('playerLeave', (playerId) => {
            removePlayer(playerId);
            addChatMessage(`Player ${playerId.slice(0, 6)} left the game`, 'system-message');
        });

        socket.on('chatMessage', (data) => {
            const player = gameState.players[data.playerId];
            if (player) {
                addChatMessage(`${player.id.slice(0, 6)}: ${data.message}`);
            }
        });

        socket.on('playerUpdate', (player) => {
            if (player.id === currentPlayer?.id) {
                currentPlayer = player;
                updateInventory(player.inventory);
            }
            updatePlayer(player);
        });

        socket.on('blockUpdate', (data) => {
            if (data.type === null) {
                if (blockMeshes[data.position]) {
                    scene.remove(blockMeshes[data.position]);
                    delete blockMeshes[data.position];
                }
            } else {
                const [x, y, z] = data.position.split(',').map(Number);
                const mesh = new THREE.Mesh(blockGeometry, blockMaterials[data.type]);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                blockMeshes[data.position] = mesh;
            }
        });

        let gameState = { players: {}, blocks: {} };

        function updatePlayerList(players) {
            gameState.players = players;
            playerList.innerHTML = '';
            Object.values(players).forEach(player => {
                addPlayer(player);
            });
        }

        function updateInventory(inventory) {
            if (!inventory) return;
            Object.entries(inventory).forEach(([type, count]) => {
                const slot = inventoryGrid.querySelector(`[data-type="${type}"]`);
                if (slot) {
                    slot.querySelector('.block-count').textContent = count;
                }
            });
        }

        function addPlayer(player) {
            const playerElement = document.createElement('div');
            playerElement.className = 'player';
            playerElement.id = `player-${player.id}`;
            playerElement.innerHTML = `
                <h3>Player ${player.id.slice(0, 6)}</h3>
                <p>Position: ${Math.round(player.position.x)}, ${Math.round(player.position.y)}, ${Math.round(player.position.z)}</p>
                <p>Health: ${player.health}</p>
                <p>Mode: ${player.movementMode || 'walk'}</p>
            `;
            playerList.appendChild(playerElement);
        }

        function updatePlayer(player) {
            const playerElement = document.getElementById(`player-${player.id}`);
            if (playerElement) {
                playerElement.innerHTML = `
                    <h3>Player ${player.id.slice(0, 6)}</h3>
                    <p>Position: ${Math.round(player.position.x)}, ${Math.round(player.position.y)}, ${Math.round(player.position.z)}</p>
                    <p>Health: ${player.health}</p>
                    <p>Mode: ${player.movementMode || 'walk'}</p>
                `;

                // Update animation classes
                playerElement.classList.remove('walking', 'running', 'crouching', 'jumping');
                if (player.movementMode === 'run') {
                    playerElement.classList.add('running');
                } else if (player.movementMode === 'crouch') {
                    playerElement.classList.add('crouching');
                } else {
                    playerElement.classList.add('walking');
                }
            }
        }

        function removePlayer(playerId) {
            const playerElement = document.getElementById(`player-${playerId}`);
            if (playerElement) {
                playerElement.remove();
            }
        }

        // Block interaction
        document.addEventListener('mousedown', (e) => {
            if (selectedBlock && currentPlayer) {
                const target = e.target;
                if (target.classList.contains('block')) {
                    startBreakingBlock(target);
                }
            }
        });

        document.addEventListener('mouseup', () => {
            stopBreakingBlock();
        });

        document.addEventListener('mousemove', (e) => {
            if (selectedBlock && currentPlayer) {
                const target = e.target;
                if (target.classList.contains('block')) {
                    updateBlockPreview(target);
                } else {
                    hideBlockPreview();
                }
            }
        });

        function startBreakingBlock(block) {
            if (breakingBlock) return;
            
            const position = block.dataset.position;
            const type = gameState.blocks[position]?.type;
            if (!type) return;

            breakingBlock = block;
            breakingProgress = 0;
            const hardness = blockTypes[type].hardness;
            
            // Show breaking progress
            const progressBar = document.querySelector('.breaking-progress-bar');
            document.getElementById('breaking-progress').classList.add('visible');
            
            // Start breaking animation
            breakingInterval = setInterval(() => {
                breakingProgress += 1 / (hardness * 10);
                progressBar.style.width = `${breakingProgress * 100}%`;
                
                if (breakingProgress >= 1) {
                    socket.emit('blockUpdate', {
                        position: position,
                        type: null
                    });
                    stopBreakingBlock();
                }
            }, 50);
        }

        function stopBreakingBlock() {
            if (breakingInterval) {
                clearInterval(breakingInterval);
                breakingInterval = null;
            }
            breakingBlock = null;
            breakingProgress = 0;
            document.getElementById('breaking-progress').classList.remove('visible');
            document.querySelector('.breaking-progress-bar').style.width = '0%';
        }

        function updateBlockPreview(block) {
            const preview = document.getElementById('block-preview');
            const position = block.dataset.position;
            const type = gameState.blocks[position]?.type;
            
            if (type) {
                preview.innerHTML = blockTypes[type].image;
                preview.classList.add('visible');
            } else {
                preview.innerHTML = blockTypes[selectedBlock].image;
                preview.classList.add('visible');
            }
        }

        function hideBlockPreview() {
            document.getElementById('block-preview').classList.remove('visible');
        }

        // Add some initial blocks
        const initialBlocks = {
            '0,0,0': { type: 'grass' },
            '1,0,0': { type: 'dirt' },
            '2,0,0': { type: 'stone' },
            '0,1,0': { type: 'wood' },
            '1,1,0': { type: 'leaves' },
            '2,1,0': { type: 'sand' }
        };

        // Update world with initial blocks
        updateWorld(initialBlocks);

        // Initialize inventory with initial blocks
        initializeInventory();
        updateInventory(currentPlayer.inventory);

        // Update status to show we're in local mode
        status.textContent = 'Status: Local Mode';
        status.className = 'connected';
    </script>
</body>
</html> 