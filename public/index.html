<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craftverse</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 100vh;
            width: 100vw;
            z-index: 0;
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        h1 {
            color: #2c3e50;
        }
        p {
            color: #34495e;
            line-height: 1.6;
        }
        #players {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        #chat {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        .player {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            min-width: 150px;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .connected {
            background: #d4edda;
            color: #155724;
        }
        .disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        #controls {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .control-btn {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        .control-btn:hover {
            background: #0056b3;
        }
        .control-btn.active {
            background: #28a745;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        .chat-message {
            text-align: left;
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .system-message {
            background: #e9ecef;
            color: #6c757d;
        }
        .player-message {
            background: #e3f2fd;
            color: #1976d2;
        }
        #chat-input {
            display: flex;
            gap: 10px;
        }
        #message-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        #send-message {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #send-message:hover {
            background: #218838;
        }
        #inventory {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .inventory-slot {
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }
        .inventory-slot.selected {
            background: #007bff;
            color: white;
        }
        .inventory-slot img {
            width: 32px;
            height: 32px;
        }
        .block-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
        }
        #block-info {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .movement-mode {
            margin-top: 10px;
            padding: 5px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .movement-mode button {
            margin: 0 5px;
            padding: 5px 10px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .movement-mode button.active {
            background: #28a745;
        }

        /* Block breaking animation */
        .block-breaking {
            position: relative;
            overflow: hidden;
        }
        .block-breaking::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            animation: breaking 1s linear forwards;
        }
        @keyframes breaking {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Player animations */
        .player {
            transition: transform 0.2s ease;
        }
        .player.walking {
            animation: walk 0.5s infinite;
        }
        .player.running {
            animation: run 0.3s infinite;
        }
        .player.crouching {
            transform: scale(0.8);
        }
        .player.jumping {
            animation: jump 0.5s ease;
        }
        @keyframes walk {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        @keyframes run {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        @keyframes jump {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        /* Block preview */
        .block-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 64px;
            height: 64px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            pointer-events: none;
            display: none;
        }
        .block-preview.visible {
            display: block;
        }

        /* Block breaking progress */
        .breaking-progress {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            display: none;
        }
        .breaking-progress.visible {
            display: block;
        }
        .breaking-progress-bar {
            width: 0%;
            height: 100%;
            background: #28a745;
            border-radius: 10px;
            transition: width 0.1s linear;
        }

        /* Enhanced inventory system */
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #666;
        }
        .hotbar-slot.selected {
            border-color: #fff;
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 12px;
        }
        .inventory-slot {
            position: relative;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
        }
        .inventory-slot img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Durability bar styles */
        .durability-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 2px;
            background: #00ff00;
            transition: width 0.2s;
        }
        .durability-bar[style*="width: 0%"] {
            background: #ff0000;
        }

        .chat-message {
            margin: 5px 0;
            padding: 5px;
            border-radius: 5px;
        }

        .player-message {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .system-message {
            background-color: rgba(255, 255, 0, 0.1);
            color: #ffd700;
        }

        #playerList {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }

        .player {
            margin: 5px 0;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .player h3 {
            margin: 0;
            font-size: 14px;
        }

        .player p {
            margin: 2px 0;
            font-size: 12px;
            color: #ccc;
        }

        #status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
        }

        .connected {
            background-color: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        .disconnected {
            background-color: rgba(255, 0, 0, 0.3);
            color: #ff0000;
        }

        .recipe {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .recipe h3 {
            margin: 0 0 10px 0;
            color: #ffd700;
        }
        
        .recipe p {
            margin: 5px 0;
        }
        
        .craft-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }
        
        .craft-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        #recipes-list {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Game Settings Panel */
        #game-settings {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 1000;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            transition: opacity 0.3s ease;
        }

        #game-settings.visible {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .settings-group {
            margin-bottom: 15px;
        }

        .settings-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .settings-option {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .settings-option label {
            margin-right: 10px;
        }

        .settings-option input[type="range"] {
            width: 150px;
        }

        .settings-option input[type="checkbox"] {
            margin-right: 5px;
        }

        /* Improved UI Styling */
        #ui-container > * {
            pointer-events: auto;
        }

        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }

        #players {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            max-width: 200px;
        }

        #chat {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            width: 300px;
        }

        #chat-messages {
            height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #chat-input {
            display: flex;
            gap: 5px;
        }

        #message-input {
            flex: 1;
            padding: 5px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        #send-message {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        #send-message:hover {
            background: #45a049;
        }

        .chat-message {
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }

        .chat-message.system-message {
            color: #4CAF50;
            font-style: italic;
        }

        .chat-message.player-message {
            color: #fff;
        }

        .chat-message .player-name {
            color: #4CAF50;
            font-weight: bold;
        }

        /* Settings Button */
        #settings-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #4CAF50;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1001;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #settings-button:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #settings-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
    </style>
</head>
<body>
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
        <div id="status">Status: Connecting...</div>

        <button id="settings-button">
            <svg viewBox="0 0 24 24">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
            </svg>
            Settings
        </button>

        <div id="game-settings">
            <div class="settings-group">
                <h3>Graphics</h3>
                <div class="settings-option">
                    <label>Render Distance:</label>
                    <input type="range" id="render-distance" min="1" max="10" value="5">
                </div>
                <div class="settings-option">
                    <label>Particles:</label>
                    <input type="checkbox" id="particles-enabled" checked>
                </div>
            </div>
            <div class="settings-group">
                <h3>Gameplay</h3>
                <div class="settings-option">
                    <label>Mouse Sensitivity:</label>
                    <input type="range" id="mouse-sensitivity" min="0.1" max="2" step="0.1" value="1">
                </div>
                <div class="settings-option">
                    <label>Auto-Save:</label>
                    <input type="checkbox" id="auto-save" checked>
                </div>
            </div>
            <div class="settings-group">
                <h3>Audio</h3>
                <div class="settings-option">
                    <label>Master Volume:</label>
                    <input type="range" id="master-volume" min="0" max="1" step="0.1" value="0.5">
                </div>
                <div class="settings-option">
                    <label>Sound Effects:</label>
                    <input type="checkbox" id="sound-effects" checked>
                </div>
            </div>
            <div class="settings-group">
                <h3>Performance</h3>
                <div class="settings-option">
                    <label>FPS Limit:</label>
                    <input type="range" id="fps-limit" min="30" max="144" step="1" value="60">
                </div>
                <div class="settings-option">
                    <label>VSync:</label>
                    <input type="checkbox" id="vsync-enabled">
                </div>
            </div>
            </div>

            <div id="players">
                <h2>Connected Players</h2>
                <div id="playerList"></div>
            </div>

            <div id="chat">
                <h2>Chat</h2>
                <div id="chat-messages"></div>
                <div id="chat-input">
                    <input type="text" id="message-input" placeholder="Type a message...">
                    <button id="send-message">Send</button>
            </div>
        </div>
    </div>

    <div class="block-preview" id="block-preview"></div>
    <div class="breaking-progress" id="breaking-progress">
        <div class="breaking-progress-bar"></div>
    </div>

    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Performance monitoring without using unload events
            // This avoids the deprecated "Unload event listeners" warning
            if (window.performance) {
                console.log('Performance API available');
                
                // Use visibilitychange instead of unload/beforeunload
                document.addEventListener('visibilitychange', function() {
                    if (document.visibilityState === 'hidden') {
                        console.log('Page is being hidden, saving state...');
                        // Save game state or perform cleanup here
                    }
                });
            }

            // At the top of your script section, add:
            const simplex = new SimplexNoise();
            
            // Mock socket for offline mode
            const socket = {
                emit: () => {},
                on: () => {},
                connected: false
            };

            // Create temporary status UI for offline mode
            const status = document.createElement('div');
            status.id = 'status';
            status.style.position = 'fixed';
            status.style.top = '10px';
            status.style.left = '10px';
            status.style.padding = '5px 10px';
            status.style.background = 'rgba(0, 0, 0, 0.5)';
            status.style.color = 'white';
            status.style.borderRadius = '5px';
            document.body.appendChild(status);

            // Initialize in offline mode
            status.textContent = 'Status: Offline Mode';

            // Function to add chat messages - defined early to be used anywhere
            function addChatMessage(message, type = 'player-message') {
                console.log(`${type}: ${message}`);
                
                // If chat UI exists, use it
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const messageElement = document.createElement('div');
                    messageElement.className = `chat-message ${type}`;
                    messageElement.textContent = message;
                    messageElement.style.marginBottom = '5px';
                    messageElement.style.padding = '5px';
                    messageElement.style.borderRadius = '3px';
                    
                    if (type === 'system-message') {
                        messageElement.style.color = '#ffcc00';
                    } else {
                        messageElement.style.color = 'white';
                    }
                    
                    chatMessages.appendChild(messageElement);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }

            // Initialize Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Create renderer with canvas
            const canvas = document.getElementById('game-canvas');
            console.log('Game canvas element:', canvas);
        const renderer = new THREE.WebGLRenderer({
                canvas: canvas, 
                antialias: true,
                alpha: false 
        });
            
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB, 1);  // Sky blue background
            
            // Force the renderer to be visible
            canvas.style.display = 'block';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '10';
            
            console.log('Renderer initialized', renderer);
            
            // Check for WebGL support
            if (!renderer.capabilities.isWebGL2) {
                console.warn('WebGL 2 not supported, using WebGL 1');
            }
            
            try {
                const context = renderer.getContext();
                if (!context) {
                    console.error('No WebGL context - rendering will fail!');
                    // Show an error message to the user
                    addChatMessage('ERROR: WebGL not supported by your browser. The game will not render properly.', 'system-message');
                } else {
                    console.log('WebGL context found:', context);
                }
            } catch (error) {
                console.error('Error getting WebGL context:', error);
                addChatMessage('ERROR: Problem with WebGL - rendering may fail.', 'system-message');
            }

            // Add window resize handler
            window.addEventListener('resize', function() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // Update renderer and camera
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                
                console.log('Window resized', width, height);
            });
            
            // Add more visible debug objects
            // Create a grid helper for perspective
            const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x888888);
            scene.add(gridHelper);
            
            // Create some colorful boxes at different positions
            const createColorfulBox = (x, y, z, color) => {
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshStandardMaterial({ color: color });
                const box = new THREE.Mesh(geometry, material);
                box.position.set(x, y, z);
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
                return box;
            };
            
            // Create multiple boxes in different colors
            createColorfulBox(-10, 1, -10, 0xff0000); // Red
            createColorfulBox(10, 1, -10, 0x00ff00);  // Green
            createColorfulBox(-10, 1, 10, 0x0000ff);  // Blue
            createColorfulBox(10, 1, 10, 0xffff00);   // Yellow

            // Game constants
            const CHUNK_SIZE = 16;
            const BLOCK_SIZE = 1;
            const CHUNK_HEIGHT = 256;
            let currentWeather = 'clear';
            let frameCount = 0;  // Add frame counter variable

            // Sound manager
            const soundManager = {
                volume: 0.5,
                weatherVolume: 0.3,
                effectsVolume: 0.8,
                musicVolume: 0.6,
                muted: false
            };
            
            // Sound system - create dummy audio objects to prevent 404 errors
            const createDummyAudio = () => {
                const audio = new Audio();
                // Don't set src to prevent 404 errors
                audio.play = function() { 
                    // Don't return a promise
                    return undefined; 
                };
                audio.pause = function() {
                    // Empty function
                };
                // Add paused property
                audio.paused = true;
                return audio;
            };

            const sounds = {
                blockBreak: createDummyAudio(),
                blockPlace: createDummyAudio(),
                playerWalk: createDummyAudio(),
                playerJump: createDummyAudio(),
                playerLand: createDummyAudio(),
                inventoryOpen: createDummyAudio(),
                inventoryClose: createDummyAudio(),
                crafting: createDummyAudio(),
                weatherRain: createDummyAudio(),
                weatherSnow: createDummyAudio(),
                swordSwing: createDummyAudio()
            };
            
            // Function to get biome based on position
            function getBiome(x, z) {
                // Sample noise at lower frequency for biome detection
                const biomeNoise = simplex.noise2D(x * 0.01, z * 0.01);
                
                if (biomeNoise < -0.6) {
                    return 'Snowy Mountains';
                } else if (biomeNoise < -0.3) {
                    return 'Mountains';
                } else if (biomeNoise < -0.1) {
                    return 'Forest';
                } else if (biomeNoise < 0.2) {
                    return 'Plains';
                } else if (biomeNoise < 0.5) {
                    return 'Desert';
                } else {
                    return 'Beach';
                }
            }

            // Function to update the block preview
            function updateBlockPreview(positionKey) {
                const blockPreview = document.getElementById('block-preview');
                if (blockPreview) {
                    blockPreview.classList.add('visible');
                    // Parse position from the position key
                    const [x, y, z] = positionKey.split(',').map(Number);
                    // You can add more visualization logic here if needed
                }
            }

            // Function to hide the block preview
            function hideBlockPreview() {
                const blockPreview = document.getElementById('block-preview');
                if (blockPreview) {
                    blockPreview.classList.remove('visible');
                }
            }

        // Add skybox
        const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const skyboxMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
        scene.add(skybox);

        // Add sun
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(50, 50, 50);
        scene.add(sun);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Add ground plane
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a9d23,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        
        // Create a colored texture as fallback
        function createColorTexture(color, blockType) {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Base color fill
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 32, 32);
            
            // Add texture details based on block type
            switch(blockType) {
                case 'grass':
                    // Add grass blades
                    ctx.fillStyle = 'rgba(30,150,10,0.6)';
                    for (let i = 0; i < 20; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        ctx.fillRect(x, y, 1, 2 + Math.random() * 3);
                    }
                    break;
                    
                case 'dirt':
                    // Add soil chunks
                    for (let i = 0; i < 30; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        ctx.fillStyle = Math.random() > 0.5 ? 
                            'rgba(110,70,40,0.7)' : 'rgba(80,50,20,0.7)';
                        ctx.fillRect(x, y, 2 + Math.random() * 3, 2 + Math.random() * 3);
                    }
                    break;
                    
                case 'stone':
                    // Add cracks and variations
                    for (let i = 0; i < 10; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        const length = 3 + Math.random() * 5;
                        const angle = Math.random() * Math.PI;
                        
                        ctx.strokeStyle = 'rgba(60,60,60,0.6)';
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                        ctx.stroke();
                        
                        // Add darker spots
                        ctx.fillStyle = 'rgba(40,40,40,0.3)';
                        ctx.fillRect(Math.random() * 32, Math.random() * 32, 4, 4);
                    }
                    break;
                    
                case 'wood':
                case 'wood_side':
                    // Add wood grain
                    for (let i = 0; i < 8; i++) {
                        ctx.fillStyle = 'rgba(90,50,20,0.4)';
                        ctx.fillRect(0, i * 4, 32, 1);
                        
                        // Add knots
                        if (Math.random() > 0.7) {
                            const knot_x = Math.random() * 32;
                            const knot_y = i * 4;
                            const radius = 1 + Math.random() * 2;
                            ctx.beginPath();
                            ctx.fillStyle = 'rgba(60,30,10,0.6)';
                            ctx.arc(knot_x, knot_y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    break;
                    
                case 'wood_top':
                    // Create tree rings
                    for (let r = 16; r > 2; r -= 2) {
                        ctx.fillStyle = r % 4 === 0 ? 
                            'rgba(110,60,20,0.6)' : 'rgba(130,70,30,0.4)';
                        ctx.beginPath();
                        ctx.arc(16, 16, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'leaves':
                    // Add leaf details
                    for (let i = 0; i < 40; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        ctx.fillStyle = Math.random() > 0.5 ? 
                            'rgba(30,100,10,0.6)' : 'rgba(40,130,20,0.6)';
                        ctx.beginPath();
                        ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'sand':
                    // Add sand grains
                    for (let i = 0; i < 100; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        ctx.fillStyle = Math.random() > 0.5 ? 
                            'rgba(240,230,140,0.6)' : 'rgba(210,180,120,0.5)';
                        ctx.fillRect(x, y, 1, 1);
                    }
                    break;
                    
                case 'water':
                    // Water will be animated separately
                    // Just add base ripples for now
                    for (let i = 0; i < 5; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        const radius = 2 + Math.random() * 5;
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;
                    
                case 'lava':
                    // Add lava bubbles and glow
                    for (let i = 0; i < 10; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        const radius = 1 + Math.random() * 3;
                        ctx.fillStyle = 'rgba(255,200,0,0.4)';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'brick':
                    // Create brick pattern
                    ctx.fillStyle = '#a52a2a';
                    const brickHeight = 8; // Define brick height
                    for (let y = 0; y < 32; y += brickHeight) {
                        const offset = (y / brickHeight) % 2 === 0 ? 0 : 16;
                        for (let x = 0; x < 32; x += 16) {
                            ctx.fillRect(x + offset, y, 14, 6);
                            // Add mortar lines
                            ctx.fillStyle = '#d3d3d3';
                            ctx.fillRect(x + offset, y + 6, 14, 2);
                            ctx.fillRect(x + offset + 14, y, 2, 8);
                            ctx.fillStyle = '#a52a2a';
                        }
                    }
                    break;
                    
                case 'snow':
                    // Add snowflake patterns
                    for (let i = 0; i < 20; i++) {
                        const x = Math.random() * 32;
                        const y = Math.random() * 32;
                        ctx.fillStyle = 'rgba(220,240,255,0.8)';
                        ctx.beginPath();
                        ctx.arc(x, y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                default:
                    // Add simple noise for other block types
                    for (let x = 0; x < 32; x += 4) {
                        for (let y = 0; y < 32; y += 4) {
                            if (Math.random() > 0.5) {
                                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                                ctx.fillRect(x, y, 2, 2);
                            }
                        }
                    }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            
            // Store the canvas context if it's water for animation
            if (blockType === 'water') {
                texture.userData = { canvas, ctx, color };
            }
            
            return texture;
        }
        
        // Function to create animated water textures
        function createWaterTextures(frameCount = 4) {
            const textures = [];
            
            for (let i = 0; i < frameCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                
                // Base water color
                ctx.fillStyle = '#3569e7';
                ctx.fillRect(0, 0, 32, 32);
                
                // Add ripples with different positions for each frame
                const rippleCount = 3 + i % 3;
                for (let j = 0; j < rippleCount; j++) {
                    const x = Math.random() * 32;
                    const y = Math.random() * 32;
                    const radius = 2 + Math.random() * 5;
                    const startAngle = (i / frameCount) * Math.PI * 2;
                    const endAngle = startAngle + Math.PI;
                    
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, startAngle, endAngle);
                    ctx.stroke();
                    
                    ctx.strokeStyle = 'rgba(30,100,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, radius - 1, endAngle, startAngle);
                    ctx.stroke();
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.LinearMipmapLinearFilter;
                
                textures.push(texture);
            }
            
            return textures;
        }
        
        // Create water animation frames
        const waterTextures = createWaterTextures(6);  // 6 frames of animation
        let waterAnimationFrame = 0;
        
        // Function to update water animation
        function updateWaterAnimation() {
            waterAnimationFrame = (waterAnimationFrame + 1) % waterTextures.length;
            
            // Update materials in waterBlocks
            Object.values(waterBlocks).forEach(block => {
                // If this is the topmost water block, animate it
                if (block.isTopWater) {
                    block.material.map = waterTextures[waterAnimationFrame];
                    block.material.needsUpdate = true;
                }
            });
        }
        
        // Water blocks tracking
        let waterBlocks = {};
        
        // Block textures with fallbacks - updated to use new createColorTexture function
        const blockTextures = {
            grass: {
                top: createColorTexture('#3baa35', 'grass'),
                side: createColorTexture('#8b7834', 'grass'),
                bottom: createColorTexture('#8b5a34', 'dirt')
            },
            dirt: createColorTexture('#8b5a34', 'dirt'),
            stone: createColorTexture('#888888', 'stone'),
            wood: {
                top: createColorTexture('#a0662c', 'wood_top'),
                side: createColorTexture('#8b5a34', 'wood_side')
            },
            leaves: createColorTexture('#378030', 'leaves'),
            sand: createColorTexture('#e0d993', 'sand'),
            water: waterTextures[0], // Start with first frame
            lava: createColorTexture('#ff4500', 'lava'),
            brick: createColorTexture('#b22222', 'brick'),
            snow: createColorTexture('#ffffff', 'snow'),
            redstone_dust: createColorTexture('#ff0000', 'redstone_dust'),
            redstone_torch: {
                top: createColorTexture('#ff0000', 'redstone_torch_top'),
                side: createColorTexture('#ff0000', 'redstone_torch_side')
            },
            redstone_block: createColorTexture('#ff0000', 'redstone_block'),
            redstone_lamp: {
                on: createColorTexture('#ffff00', 'redstone_lamp_on'),
                off: createColorTexture('#404040', 'redstone_lamp_off')
            },
            redstone_repeater: createColorTexture('#ff0000', 'redstone_repeater'),
            redstone_comparator: createColorTexture('#ff0000', 'redstone_comparator')
        };

        // Block materials
        const blockMaterials = {
            grass: [
                new THREE.MeshStandardMaterial({ map: blockTextures.grass.side }), // Right
                new THREE.MeshStandardMaterial({ map: blockTextures.grass.side }), // Left
                new THREE.MeshStandardMaterial({ map: blockTextures.grass.top }),  // Top
                new THREE.MeshStandardMaterial({ map: blockTextures.grass.bottom }), // Bottom
                new THREE.MeshStandardMaterial({ map: blockTextures.grass.side }), // Front
                new THREE.MeshStandardMaterial({ map: blockTextures.grass.side })  // Back
            ],
            dirt: new THREE.MeshStandardMaterial({ map: blockTextures.dirt }),
            stone: new THREE.MeshStandardMaterial({ map: blockTextures.stone }),
            wood: [
                new THREE.MeshStandardMaterial({ map: blockTextures.wood.side }), // Right
                new THREE.MeshStandardMaterial({ map: blockTextures.wood.side }), // Left
                new THREE.MeshStandardMaterial({ map: blockTextures.wood.top }),  // Top
                new THREE.MeshStandardMaterial({ map: blockTextures.wood.top }),  // Bottom
                new THREE.MeshStandardMaterial({ map: blockTextures.wood.side }), // Front
                new THREE.MeshStandardMaterial({ map: blockTextures.wood.side })  // Back
            ],
            leaves: new THREE.MeshStandardMaterial({ 
                map: blockTextures.leaves,
                transparent: true,
                alphaTest: 0.5
            }),
            sand: new THREE.MeshStandardMaterial({ map: blockTextures.sand }),
            water: new THREE.MeshStandardMaterial({ 
                map: waterTextures[0],  // Start with first frame
                transparent: true,
                opacity: 0.7
            }),
            lava: new THREE.MeshStandardMaterial({ 
                map: blockTextures.lava,
                emissive: 0xff4500,
                emissiveIntensity: 0.5
            }),
            glass: new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            }),
            brick: new THREE.MeshStandardMaterial({ map: blockTextures.brick }),
            snow: new THREE.MeshStandardMaterial({ map: blockTextures.snow }),
            redstone_dust: new THREE.MeshStandardMaterial({ 
                map: blockTextures.redstone_dust,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            }),
            redstone_torch: [
                new THREE.MeshStandardMaterial({ map: blockTextures.redstone_torch.side }),
                new THREE.MeshStandardMaterial({ map: blockTextures.redstone_torch.side }),
                new THREE.MeshStandardMaterial({ map: blockTextures.redstone_torch.top }),
                new THREE.MeshStandardMaterial({ map: blockTextures.redstone_torch.top }),
                new THREE.MeshStandardMaterial({ map: blockTextures.redstone_torch.side }),
                new THREE.MeshStandardMaterial({ map: blockTextures.redstone_torch.side })
            ],
            redstone_block: new THREE.MeshStandardMaterial({ 
                map: blockTextures.redstone_block,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            }),
            redstone_lamp: new THREE.MeshStandardMaterial({ 
                map: blockTextures.redstone_lamp.off,
                emissive: 0x000000,
                emissiveIntensity: 0
            }),
            redstone_repeater: new THREE.MeshStandardMaterial({ 
                map: blockTextures.redstone_repeater,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            }),
            redstone_comparator: new THREE.MeshStandardMaterial({ 
                map: blockTextures.redstone_comparator,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            })
        };

        // Mouse controls
        let isPointerLocked = false;
        const moveSpeed = 0.1;
        const keys = {};
        
        // Camera rotation variables
        let pitch = 0; // Looking up/down
        let yaw = 0;   // Looking left/right
        
        // Jump state system
        const jumpState = {
            READY: 'ready',        // Can jump when spacebar is pressed
            JUMPING: 'jumping',    // Currently in a jump
            FALLING: 'falling',    // Falling after a jump
            COOLDOWN: 'cooldown'   // Brief cooldown after landing
        };
        
        // Jump control variables
        let currentJumpState = jumpState.READY;
        let jumpKeyWasPressed = false;   // Tracks if key was pressed this frame
        let jumpKeyWasReleased = true;   // Must release key before jumping again
        let jumpCooldownTimer = 0;       // Frames to wait after landing

        // Block geometries
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let blockMeshes = {};
        let selectedBlock = null;
        let initialBlocks = {}; // Initialize early to prevent reference error

        // Player physics constants
        const playerPhysics = {
            height: 2,               // Player is 2 blocks tall
            gravity: 0.01,           // Gravity acceleration
            jumpForce: 0.3,          // Jump force - should be 0.3 not 0.6
            jumpHeight: 1.5,         // Max jump height in blocks
            velocity: new THREE.Vector3(0, 0, 0),
            grounded: false,
            airControl: 0.3,         // How much control in air (0-1)
            friction: 0.85,          // Ground friction (reduced for smoother movement)
            airFriction: 0.98,       // Air friction (0-1) - higher is less drag
            acceleration: 0.01,      // Increased acceleration for more responsive controls
            maxSpeed: 0.15,          // Maximum player speed
            sprintMaxSpeed: 0.45,    // Maximum speed when sprinting (3x normal)
            collisionPadding: 0.2    // Reduced padding for less aggressive collisions (was 0.3)
        };

        // Camera position - move it higher and further back
        camera.position.set(0, 5, 30);  // Move further back to see more
        
        // Set initial camera rotation properties
        camera.rotation.order = 'YXZ'; // Important for proper FPS camera
        camera.lookAt(0, 0, 0);

        // Initialize pitch and yaw based on initial camera rotation
        pitch = camera.rotation.x;
        yaw = camera.rotation.y;
        
        // Set initial position to ensure player doesn't start inside terrain
        camera.position.y = Math.max(camera.position.y, playerPhysics.height / 2);
        
        console.log('Camera positioned at:', camera.position);

        // Add a debug box to make sure something is visible
        const debugBoxGeometry = new THREE.BoxGeometry(5, 5, 5);
        const debugBoxMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const debugBox = new THREE.Mesh(debugBoxGeometry, debugBoxMaterial);
        debugBox.position.set(0, 0, 0);
        scene.add(debugBox);

        // Add raycaster for block interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        document.addEventListener('click', (event) => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
            } else {
                // Calculate mouse position in normalized device coordinates
                    mouse.x = 0; // Center of screen
                    mouse.y = 0; // Center of screen

                // Update raycaster
                raycaster.setFromCamera(mouse, camera);

                // Find intersected blocks
                    const intersects = raycaster.intersectObjects(Object.values(blockMeshes));
                    
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                        const mesh = intersect.object;
                        const position = mesh.position.clone();
                    const positionKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;
                    
                        // Left click - Break block
                        if (event.button === 0) {
                        // Remove block
                            sounds.blockBreak.play();
                            scene.remove(mesh);
                            delete blockMeshes[positionKey];
                            delete initialBlocks[positionKey];
                        }
                        // Right click - Place block
                        else if (event.button === 2 && selectedBlock) {
                            // Calculate position for new block
                            const normal = intersect.face.normal;
                            const newPosition = position.clone().add(normal);
                            const newPositionKey = `${Math.round(newPosition.x)},${Math.round(newPosition.y)},${Math.round(newPosition.z)}`;
                            
                            // Check if position is already occupied
                            if (!blockMeshes[newPositionKey]) {
                                // Create new block
                                sounds.blockPlace.play();
                                const mesh = createBlock(selectedBlock, newPosition);
                                scene.add(mesh);
                                blockMeshes[newPositionKey] = mesh;
                                initialBlocks[newPositionKey] = { type: selectedBlock };
                            }
                    }
                }
            }
        });
            
            // Prevent context menu
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // Track spacebar for jumping - detect new presses
            if ((e.code === 'Space' || e.code === 'SpaceBar') && !jumpKeyWasPressed) {
                jumpKeyWasPressed = true;
                console.log('Jump key DOWN - State:', currentJumpState, 'Grounded:', playerPhysics.grounded);
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            
            // Track spacebar for jumping - detect releases
            if (e.code === 'Space' || e.code === 'SpaceBar') {
                jumpKeyWasPressed = false;
                jumpKeyWasReleased = true;
                console.log('Jump key UP - State:', currentJumpState, 'Ready for next jump');
            }
        });
        
        // Add additional key mappings to handle different browsers
        function updateKeyMappings() {
            // Map Space to Spacebar for consistency
            if (keys['Space']) keys['SpaceBar'] = true;
            if (keys['SpaceBar']) keys['Space'] = true;
            
            // Map Shift keys for consistency
            if (keys['ShiftLeft'] || keys['ShiftRight']) keys['Shift'] = true;
            else keys['Shift'] = false;
        }

            // Add crosshair to center of screen
            const crosshair = document.createElement('div');
            crosshair.id = 'crosshair';
            crosshair.style.position = 'fixed';
            crosshair.style.top = '50%';
            crosshair.style.left = '50%';
            crosshair.style.transform = 'translate(-50%, -50%)';
            crosshair.style.width = '10px';
            crosshair.style.height = '10px';
            crosshair.style.borderRadius = '50%';
            crosshair.style.border = '2px solid white';
            crosshair.style.pointerEvents = 'none';
            document.body.appendChild(crosshair);

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                // Update yaw (left/right) and pitch (up/down)
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                
                // Clamp pitch to prevent flipping
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                
                // Apply rotations to camera while keeping it upright
                camera.rotation.order = 'YXZ'; // Important for proper FPS controls
                camera.rotation.x = pitch;
                camera.rotation.y = yaw;
                camera.rotation.z = 0; // Keep camera upright, no roll
                
                // Update raycaster for block preview
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(Object.values(blockMeshes));
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const normal = intersect.face.normal;
                    const position = intersect.object.position.clone();
                    const newPosition = position.clone().add(normal);
                    
                    // Update crosshair color based on interaction
                    if (selectedBlock) {
                        crosshair.style.borderColor = 'lime'; // Place mode
                } else {
                        crosshair.style.borderColor = 'red';  // Break mode
                    }
                } else {
                    // Reset crosshair if not pointing at a block
                    crosshair.style.borderColor = 'white';
                }
            }
        });

        // Update world
        function updateWorld(world) {
            // Reset water blocks tracking
            waterBlocks = {};
            
            // Remove old blocks
            Object.values(blockMeshes).forEach(mesh => {
                scene.remove(mesh);
            });
            blockMeshes = {};

            // Add new blocks - handle both formats
            const blocksToProcess = world.blocks || world;
            
            Object.entries(blocksToProcess).forEach(([position, block]) => {
                const [x, y, z] = position.split(',').map(Number);
                const material = blockMaterials[block.type];
                const mesh = new THREE.Mesh(blockGeometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.blockType = block.type; // Store block type for reference
                
                // Track water blocks for animation
                if (block.type === 'water') {
                    waterBlocks[position] = mesh;
                }
                
                scene.add(mesh);
                blockMeshes[position] = mesh;
            });
            
            // After loading all blocks, determine which water blocks are on top
            updateWaterBlockStatus();
        }
        
        // Helper function to create new block
        function createBlock(blockType, position) {
            const material = blockMaterials[blockType];
            const mesh = new THREE.Mesh(blockGeometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.blockType = blockType; // Store block type for reference
            
            // If it's a water block, add it to our water blocks collection
            if (blockType === 'water') {
                const posKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;
                waterBlocks[posKey] = mesh;
                // Initially mark all water blocks as top
                mesh.userData.isTopWater = true;
            }
            
            return mesh;
        }

            // Set initial player state
            let currentPlayer = {
                id: 'local-player',
                position: { x: 0, y: 2, z: 5 },
                health: 100,
                inventory: {
                    grass: 64,
                    dirt: 64,
                    stone: 64,
                    wood: 64,
                    leaves: 64,
                    sand: 64
                }
            };

        // Player idle animation
        let idleTime = 0;
        const idleAnimation = () => {
            idleTime += 0.02;
                if (!keys['KeyW'] && !keys['KeyS'] && !keys['KeyA'] && !keys['KeyD']) {
                const playerElement = document.getElementById(`player-${currentPlayer.id}`);
                if (playerElement) {
                    playerElement.style.transform = `translateY(${Math.sin(idleTime) * 2}px)`;
                }
            }
        };

            // Day/night cycle
            const dayNight = {
                timeOfDay: 0, // 0 to 1, where 0 is dawn
                dayLength: 1200000, // 20 minutes in milliseconds
                lastTime: Date.now(),
                sun: new THREE.DirectionalLight(0xffffff, 1),
                moon: new THREE.DirectionalLight(0x404040, 0.5),
                skyColor: new THREE.Color(0x87CEEB), // Sky blue
                nightColor: new THREE.Color(0x000033), // Dark blue
                fog: new THREE.Fog(0x87CEEB, 20, 100)
            };

            // Initialize day/night cycle
            function initDayNight() {
                // Add sun and moon
                dayNight.sun.position.set(50, 50, 50);
                dayNight.sun.castShadow = true;
                dayNight.sun.shadow.mapSize.width = 2048;
                dayNight.sun.shadow.mapSize.height = 2048;
                scene.add(dayNight.sun);

                dayNight.moon.position.set(-50, 50, -50);
                dayNight.moon.castShadow = true;
                dayNight.moon.shadow.mapSize.width = 2048;
                dayNight.moon.shadow.mapSize.height = 2048;
                scene.add(dayNight.moon);

                // Add sky color
                scene.background = dayNight.skyColor;
                scene.fog = dayNight.fog;
            }

            // Update day/night cycle
            function updateDayNight() {
                const currentTime = Date.now();
                const deltaTime = currentTime - dayNight.lastTime;
                dayNight.timeOfDay = (dayNight.timeOfDay + deltaTime / dayNight.dayLength) % 1;
                dayNight.lastTime = currentTime;

                // Calculate sun and moon positions
                const sunAngle = dayNight.timeOfDay * Math.PI * 2;
                dayNight.sun.position.x = Math.cos(sunAngle) * 50;
                dayNight.sun.position.z = Math.sin(sunAngle) * 50;
                dayNight.moon.position.x = -Math.cos(sunAngle) * 50;
                dayNight.moon.position.z = -Math.sin(sunAngle) * 50;

                // Update lighting intensity
                const isNight = dayNight.timeOfDay > 0.5;
                dayNight.sun.intensity = isNight ? 0.1 : 1;
                dayNight.moon.intensity = isNight ? 0.5 : 0.1;

                // Update sky color
                const skyColor = new THREE.Color();
                if (isNight) {
                    skyColor.lerpColors(dayNight.skyColor, dayNight.nightColor, (dayNight.timeOfDay - 0.5) * 2);
                } else {
                    skyColor.lerpColors(dayNight.nightColor, dayNight.skyColor, dayNight.timeOfDay * 2);
                }
                scene.background = skyColor;
                scene.fog.color = skyColor;

                // Update fog density based on time of day
                scene.fog.density = isNight ? 0.05 : 0.02;
            }

            // Update night objects visibility
            function updateNightObjects() {
                const isNight = dayNight.timeOfDay > 0.5;
                
                // Check both moons (direct moon object and dayNight.moon)
                if (typeof moon !== 'undefined') {
                    moon.visible = isNight;
                }
                
                if (typeof dayNight !== 'undefined' && dayNight.moon) {
                    dayNight.moon.visible = isNight;
                }
                
                // Only try to update stars if they exist
                if (typeof stars !== 'undefined' && stars.length > 0) {
                    stars.forEach(star => {
                        star.visible = isNight;
                    });
                }
            }

            // Update lighting intensity
            function updateLighting() {
                let intensity;
                if (dayNight.timeOfDay < 0.25) {
                    // Dawn to noon
                    intensity = 0.6 + (dayNight.timeOfDay * 4) * 0.4;
                } else if (dayNight.timeOfDay < 0.5) {
                    // Noon to dusk
                    intensity = 1 - ((dayNight.timeOfDay - 0.25) * 4) * 0.4;
                } else if (dayNight.timeOfDay < 0.75) {
                    // Dusk to night
                    intensity = 0.6 - ((dayNight.timeOfDay - 0.5) * 4) * 0.6;
                } else {
                    // Night to dawn
                    intensity = 0 + ((dayNight.timeOfDay - 0.75) * 4) * 0.6;
                }
                ambientLight.intensity = intensity * 0.6;
                directionalLight.intensity = intensity;
            }

            // Function to update biome indicator
            function updateBiomeIndicator() {
                // Get current biome based on player position
                const biomeIndicator = document.getElementById('biome-indicator');
                if (biomeIndicator) {
                    const x = Math.floor(camera.position.x);
                    const z = Math.floor(camera.position.z);
                    const biome = getBiome(x, z);
                    biomeIndicator.textContent = `Biome: ${biome}`;
                }
            }

            // Update weather sounds
            function updateWeatherSounds() {
                if (currentWeather === 'rain') {
                    if (sounds.weatherRain.paused) {
                        sounds.weatherRain.volume = soundManager.volume * soundManager.weatherVolume;
                        sounds.weatherRain.loop = true;
                        sounds.weatherRain.play();
                    }
                } else {
                    sounds.weatherRain.pause();
                }

                if (currentWeather === 'snow') {
                    if (sounds.weatherSnow.paused) {
                        sounds.weatherSnow.volume = soundManager.volume * soundManager.weatherVolume;
                        sounds.weatherSnow.loop = true;
                        sounds.weatherSnow.play();
                    }
                } else {
                    sounds.weatherSnow.pause();
                }
            }

        // Initialize inventory
        function initializeInventory() {
                // Create inventory UI if it doesn't exist
                if (!document.getElementById('inventory-container')) {
                    const inventoryContainer = document.createElement('div');
                    inventoryContainer.id = 'inventory-container';
                    inventoryContainer.style.display = 'none';
                    inventoryContainer.style.position = 'fixed';
                    inventoryContainer.style.top = '50%';
                    inventoryContainer.style.left = '50%';
                    inventoryContainer.style.transform = 'translate(-50%, -50%)';
                    inventoryContainer.style.background = 'rgba(0, 0, 0, 0.8)';
                    inventoryContainer.style.padding = '20px';
                    inventoryContainer.style.borderRadius = '10px';
                    inventoryContainer.style.zIndex = '1000';
                    
                    inventoryContainer.innerHTML = `
                        <h2>Inventory</h2>
                        <div id="inventory-grid" class="inventory-grid"></div>
                        <div id="hotbar" class="hotbar"></div>
                        <button id="close-inventory">Close</button>
                    `;
                    document.body.appendChild(inventoryContainer);
                    
                    // Add hotbar to UI
                    const hotbarContainer = document.createElement('div');
                    hotbarContainer.id = 'hotbar-container';
                    hotbarContainer.style.position = 'fixed';
                    hotbarContainer.style.bottom = '20px';
                    hotbarContainer.style.left = '50%';
                    hotbarContainer.style.transform = 'translateX(-50%)';
                    hotbarContainer.style.display = 'flex';
                    hotbarContainer.style.gap = '5px';
                    hotbarContainer.style.padding = '10px';
                    hotbarContainer.style.background = 'rgba(0, 0, 0, 0.5)';
                    hotbarContainer.style.borderRadius = '5px';
                    
                    const hotbar = document.createElement('div');
                    hotbar.id = 'hotbar';
                    hotbar.style.display = 'flex';
                    hotbar.style.gap = '5px';
                    hotbarContainer.appendChild(hotbar);
                    document.body.appendChild(hotbarContainer);
                    
                    // Update inventory with some default items
                    updateInventoryUI();
                    
                    // Close inventory button
                    document.getElementById('close-inventory').addEventListener('click', () => {
                        document.getElementById('inventory-container').style.display = 'none';
                    });
                }
            }

            // Update inventory UI
            function updateInventoryUI() {
                // Create inventory slots
        const inventoryGrid = document.getElementById('inventory-grid');
                if (inventoryGrid) {
            inventoryGrid.innerHTML = '';
                    for (let i = 0; i < 36; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                        slot.dataset.slot = i;
                inventoryGrid.appendChild(slot);
                    }
                }
                
                // Create hotbar slots with default blocks
                const hotbar = document.getElementById('hotbar');
                if (hotbar) {
                    hotbar.innerHTML = '';
                    
                    // Default block types for hotbar
                    const hotbarBlocks = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'water', 'brick', 'snow'];
                    
                    for (let i = 0; i < 9; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'hotbar-slot';
                        if (i === 0) {
                            slot.classList.add('selected');
                            selectedBlock = hotbarBlocks[i];
                        }
                        slot.dataset.slot = i;
                        slot.dataset.block = hotbarBlocks[i];
                        
                        // Add block icon
                        const blockIcon = document.createElement('div');
                        blockIcon.style.width = '80%';
                        blockIcon.style.height = '80%';
                        blockIcon.style.margin = '10%';
                        
                        // Use block color instead of trying to access texture URLs
                        const blockType = hotbarBlocks[i];
                        
                        // Define colors that match our createColorTexture function
                        const blockColors = {
                            grass: '#3baa35',
                            dirt: '#8b5a34',
                            stone: '#888888',
                            wood: '#8b5a34',
                            leaves: '#378030',
                            sand: '#e0d993',
                            water: '#3569e7',
                            lava: '#ff4500',
                            brick: '#b22222',
                            snow: '#ffffff'
                        };
                        
                        // Apply color
                        blockIcon.style.backgroundColor = blockColors[blockType] || '#ffffff';
                        
                        // Add texture-like pattern with box-shadow
                        blockIcon.style.boxShadow = 'inset 2px 2px 2px rgba(255,255,255,0.2), inset -2px -2px 2px rgba(0,0,0,0.2)';
                        
                        slot.appendChild(blockIcon);
                        
                        // Add click event to select block
                        slot.addEventListener('click', (e) => {
                            e.stopPropagation();
                            document.querySelectorAll('.hotbar-slot').forEach(s => s.classList.remove('selected'));
                            slot.classList.add('selected');
                            selectedBlock = slot.dataset.block;
                            console.log('Selected block:', selectedBlock);
                        });
                        
                        hotbar.appendChild(slot);
                    }
                }
            }

            // Add number key controls for hotbar selection
            document.addEventListener('keydown', (e) => {
                const keyNum = parseInt(e.key);
                if (!isNaN(keyNum) && keyNum >= 1 && keyNum <= 9) {
                    const index = keyNum - 1;
                    const slots = document.querySelectorAll('.hotbar-slot');
                    if (slots[index]) {
                        slots.forEach(s => s.classList.remove('selected'));
                        slots[index].classList.add('selected');
                        selectedBlock = slots[index].dataset.block;
                        console.log('Selected block:', selectedBlock);
                    }
                }
            });

            // Add biome indicator to UI
            const biomeIndicator = document.createElement('div');
            biomeIndicator.id = 'biome-indicator';
            biomeIndicator.style.position = 'fixed';
            biomeIndicator.style.top = '40px';
            biomeIndicator.style.left = '10px';
            biomeIndicator.style.padding = '5px 10px';
            biomeIndicator.style.background = 'rgba(0, 0, 0, 0.5)';
            biomeIndicator.style.color = 'white';
            biomeIndicator.style.borderRadius = '5px';
            document.body.appendChild(biomeIndicator);
            biomeIndicator.textContent = 'Biome: Loading...';

            // Initialize weather function variable before use in animate
            let weatherUpdateFunction = () => {}; // Empty function as placeholder

            // Function to check if a block exists at given coordinates
            function getBlockAt(x, y, z) {
                const positionKey = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
                return initialBlocks[positionKey];
            }
            
            // Function to check if a position is inside a solid block
            function isPositionSolid(position) {
                // Check if we're at a valid position to prevent errors
                if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)) {
                    console.error("Invalid position check:", position);
                    return false;
                }
                
                // Round position to nearest block coordinates
                const x = Math.floor(position.x);
                const y = Math.floor(position.y);
                const z = Math.floor(position.z);
                
                const positionKey = `${x},${y},${z}`;
                const block = initialBlocks[positionKey];
                
                // Debug collision periodically
                if (frameCount % 300 === 0 && block) {
                    console.log("Block type at position:", positionKey, "is", block.type);
                }
                
                // Consider all blocks except water as solid
                return block && block.type !== 'water';
            }
            
            // Improved function to check nearby positions for blocks
            function isNearSolidGround(position, radius) {
                // Check in a small radius around the position for any solid blocks
                for (let xOffset = -radius; xOffset <= radius; xOffset += radius) {
                    for (let zOffset = -radius; zOffset <= radius; zOffset += radius) {
                        const checkPos = new THREE.Vector3(
                            position.x + xOffset,
                            position.y,
                            position.z + zOffset
                        );
                        
                        if (isPositionSolid(checkPos)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Function to handle player collisions
            function handlePlayerCollisions() {
                const p = camera.position;
                const size = playerPhysics.collisionPadding;
                
                // Check for ground collision with a wider area
                let groundContact = false;
                
                // To fix jumping: First check if we're already falling
                // If velocity.y is negative, we're falling and should check for ground
                const isFalling = playerPhysics.velocity.y < 0;
                
                // Floor position is 0.5 blocks below player center due to player height
                const floorY = p.y - (playerPhysics.height / 2);
                
                // Debug info about ground checking
                if (frameCount % 120 === 0) {
                    console.log(`Ground check at position: ${p.x.toFixed(1)}, ${floorY.toFixed(1)}, ${p.z.toFixed(1)}`);
                }
                
                // Array of points to check below player (wider area)
                const groundCheckPoints = [
                    // Center point
                    new THREE.Vector3(p.x, floorY - 0.05, p.z),
                    // Cardinal directions (increased radius to check more blocks)
                    new THREE.Vector3(p.x + 0.4, floorY - 0.05, p.z),
                    new THREE.Vector3(p.x - 0.4, floorY - 0.05, p.z),
                    new THREE.Vector3(p.x, floorY - 0.05, p.z + 0.4),
                    new THREE.Vector3(p.x, floorY - 0.05, p.z - 0.4),
                    // Diagonals
                    new THREE.Vector3(p.x + 0.3, floorY - 0.05, p.z + 0.3),
                    new THREE.Vector3(p.x - 0.3, floorY - 0.05, p.z - 0.3),
                    new THREE.Vector3(p.x + 0.3, floorY - 0.05, p.z - 0.3),
                    new THREE.Vector3(p.x - 0.3, floorY - 0.05, p.z + 0.3)
                ];
                
                // Check all ground points
                for (const point of groundCheckPoints) {
                    if (isPositionSolid(point)) {
                        if (keys['Space'] || keys['SpaceBar']) {
                            console.log(`Ground hit at: ${point.x.toFixed(1)}, ${point.y.toFixed(1)}, ${point.z.toFixed(1)}`);
                        }
                        groundContact = true;
                        break;
                    }
                }
                
                // Double-check with our new function for broader detection
                if (!groundContact) {
                    const groundCheckPosition = new THREE.Vector3(p.x, floorY - 0.05, p.z);
                    if (isNearSolidGround(groundCheckPosition, 0.4)) {
                        groundContact = true;
                        if (frameCount % 120 === 0) {
                            console.log("Found ground via broad detection");
                        }
                    }
                }
                
                // ANTI-BOUNCE: Always set velocity to 0 when making ground contact after falling
                if (groundContact && isFalling) {
                    playerPhysics.velocity.y = 0;
                }
                
                // Update grounded state and fix position if needed
                if (groundContact) {
                    // We hit ground - set y position and zero vertical velocity
                    if (isFalling) {
                        camera.position.y = Math.ceil(floorY) + (playerPhysics.height / 2);
                        playerPhysics.velocity.y = 0;
                        
                        // Only set grounded if we weren't already grounded
                        if (!playerPhysics.grounded) {
                            playerPhysics.grounded = true;
                            
                            // If we were jumping or falling, enter cooldown state
                            if (currentJumpState === jumpState.FALLING) {
                                currentJumpState = jumpState.COOLDOWN;
                                jumpCooldownTimer = 5; // Reduced from 10 to 5 frames
                                console.log("Landed after jump - In collision cooldown");
                            }
                        }
                    } else {
                        playerPhysics.grounded = true;
                    }
                    
                    if (frameCount % 60 === 0) {
                        console.log("Ground contact detected - Player is grounded at Y:", camera.position.y.toFixed(2));
                    }
                } else {
                    // No ground contact - player is in the air
                    playerPhysics.grounded = false;
                    
                    // If player is in READY state but not grounded, change to FALLING
                    if (currentJumpState === jumpState.READY) {
                        currentJumpState = jumpState.FALLING;
                    }
                }
                
                // Force grounding on flat surfaces like the initial terrain
                if (camera.position.y <= 1.0 && playerPhysics.velocity.y <= 0) {
                    if (!playerPhysics.grounded) {
                        // Just landed
                        playerPhysics.grounded = true;
                        
                        // Handle state transition
                        if (currentJumpState === jumpState.FALLING) {
                            currentJumpState = jumpState.COOLDOWN;
                            jumpCooldownTimer = 5; // Reduced from 10 to 5 frames
                            console.log("Landed on flat surface - In cooldown");
                        }
                    }
                    
                    playerPhysics.velocity.y = 0;
                    camera.position.y = 1.0; // Player height is 2, so center is at y=1
                }
                
                // Debug what block player is standing on
                if (frameCount % 180 === 0) {
                    const x = Math.floor(p.x);
                    const y = Math.floor(p.y - (playerPhysics.height / 2) - 0.1);
                    const z = Math.floor(p.z);
                    const blockKey = `${x},${y},${z}`;
                    const block = initialBlocks[blockKey];
                    
                    console.log("Player is above block:", block ? block.type : "none", 
                        "at position", blockKey, 
                        "Grounded:", playerPhysics.grounded,
                        "Jump State:", currentJumpState);
                }
                
                // Check for ceiling collisions (head)
                const headCheckPoints = [
                    new THREE.Vector3(p.x, p.y + playerPhysics.height/2 + 0.05, p.z),
                    new THREE.Vector3(p.x + 0.2, p.y + playerPhysics.height/2 + 0.05, p.z),
                    new THREE.Vector3(p.x - 0.2, p.y + playerPhysics.height/2 + 0.05, p.z),
                    new THREE.Vector3(p.x, p.y + playerPhysics.height/2 + 0.05, p.z + 0.2),
                    new THREE.Vector3(p.x, p.y + playerPhysics.height/2 + 0.05, p.z - 0.2)
                ];
                
                let ceilingContact = false;
                for (const point of headCheckPoints) {
                    if (isPositionSolid(point)) {
                        ceilingContact = true;
                        break;
                    }
                }
                
                if (ceilingContact) {
                    // Move player down to resolve collision
                    camera.position.y = Math.floor(p.y + playerPhysics.height/2) - playerPhysics.height/2 - 0.05;
                    
                    // ANTI-BOUNCE: Stop upward momentum and move straight to FALLING state
                    if (playerPhysics.velocity.y > 0) {
                        playerPhysics.velocity.y = 0;
                        if (currentJumpState === jumpState.JUMPING) {
                            currentJumpState = jumpState.FALLING;
                            console.log("Hit ceiling - Forced to FALLING state");
                        }
                    }
                }
                
                // Check horizontal collisions with improved anti-bounce
                checkHorizontalCollisions(p, size);
            }
            
            // Separate function for horizontal collisions
            function checkHorizontalCollisions(p, size) {
                const directions = [
                    new THREE.Vector3(size, 0, 0),  // Right
                    new THREE.Vector3(-size, 0, 0), // Left
                    new THREE.Vector3(0, 0, size),  // Forward
                    new THREE.Vector3(0, 0, -size)  // Backward
                ];
                
                let horizontalCollision = false;
                
                directions.forEach(dir => {
                    // Less aggressive collision - check only at waist height
                    // This allows player to get closer to blocks
                    const waistPos = new THREE.Vector3(p.x + dir.x, p.y, p.z + dir.z);
                    
                    if (isPositionSolid(waistPos)) {
                        // Track that we had a collision for debugging
                        horizontalCollision = true;
                        
                        // Move player back just enough to prevent clipping
                        const pushbackDistance = 0.1; // Smaller pushback (was full size)
                        camera.position.x -= dir.x * (pushbackDistance / size);
                        camera.position.z -= dir.z * (pushbackDistance / size);
                        
                        // ANTI-BOUNCE: Only zero horizontal velocity in the collision direction
                        if (dir.x > 0 && playerPhysics.velocity.x > 0) playerPhysics.velocity.x = 0;
                        if (dir.x < 0 && playerPhysics.velocity.x < 0) playerPhysics.velocity.x = 0;
                        if (dir.z > 0 && playerPhysics.velocity.z > 0) playerPhysics.velocity.z = 0;
                        if (dir.z < 0 && playerPhysics.velocity.z < 0) playerPhysics.velocity.z = 0;
                        
                        if (frameCount % 120 === 0) {
                            console.log("Collision with block, gentle pushback applied");
                        }
                    }
                });
                
                // Debug horizontal collisions - could be causing unwanted bounces
                if (horizontalCollision && playerPhysics.velocity.y > 0 && 
                    currentJumpState !== jumpState.JUMPING) {
                    console.error("POTENTIAL BOUNCE DETECTED! Y velocity:", 
                        playerPhysics.velocity.y, "during horizontal collision");
                    
                    // ANTI-BOUNCE: Force Y velocity to zero if we're not in a valid jump
                    if (currentJumpState !== jumpState.JUMPING) {
                        playerPhysics.velocity.y = 0;
                    }
                }
            }

            // Initialize day/night cycle
            initDayNight();
            
            // Initialize inventory
            initializeInventory();
            
            // Start animation
            console.log('Starting animation loop');
            animate();
            console.log('Animation loop started');
            
            // Add a visible message on the canvas to confirm rendering
            addChatMessage('Game world initialized! If you see a white screen, check console for errors.', 'system-message');

            // Add event listeners for settings button
            document.getElementById('settings-button').addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event bubbling to the document
                document.getElementById('game-settings').classList.toggle('visible');
            });

            // Prevent pointer lock when clicking on UI elements
            document.querySelectorAll('#ui-container, #game-settings').forEach(element => {
                element.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent the click from bubbling to document
                });
            });

            // Generate terrain
            function generateTerrain() {
                const blocks = {};
                const chunkSize = CHUNK_SIZE;
                const heightScale = 10;
                const noiseScale = 0.05;
                
                for (let x = -chunkSize; x < chunkSize; x++) {
                    for (let z = -chunkSize; z < chunkSize; z++) {
                        // Get biome
                        const biome = getBiome(x, z);
                        
                        // Generate height based on noise
                        const noise = simplex.noise2D(x * noiseScale, z * noiseScale);
                        let height = Math.floor((noise + 1) * heightScale);
                        
                        // Adjust height based on biome
                        if (biome === 'Mountains') {
                            height += 5;
                        } else if (biome === 'Snowy Mountains') {
                            height += 8;
                        } else if (biome === 'Beach') {
                            height = 1;
                        }
                        
                        // Add blocks at different heights
                        for (let y = 0; y <= height; y++) {
                            const positionKey = `${x},${y},${z}`;
                            let blockType = 'dirt';
                            
                            // Top layer
                            if (y === height) {
                                if (biome === 'Desert') {
                                    blockType = 'sand';
                                } else if (biome === 'Beach') {
                                    blockType = 'sand';
                                } else if (biome === 'Snowy Mountains' && height > 10) {
                                    blockType = 'snow';
                } else {
                                    blockType = 'grass';
                                }
                            } 
                            // Bottom layer
                            else if (y < height - 3) {
                                blockType = 'stone';
                            }
                            
                            // Add water for low areas
                            if (y <= 1 && blockType !== 'sand') {
                                blockType = 'water';
                            }
                            
                            blocks[positionKey] = { type: blockType };
                        }
                        
                        // Add trees randomly in forest biomes
                        if (biome === 'Forest' && Math.random() < 0.1) {
                            const treeHeight = 4 + Math.floor(Math.random() * 3);
                            // Tree trunk
                            for (let y = height + 1; y < height + treeHeight; y++) {
                                blocks[`${x},${y},${z}`] = { type: 'wood' };
                            }
                            // Tree leaves
                            for (let lx = -2; lx <= 2; lx++) {
                                for (let ly = 0; ly <= 2; ly++) {
                                    for (let lz = -2; lz <= 2; lz++) {
                                        const leafX = x + lx;
                                        const leafY = height + treeHeight + ly;
                                        const leafZ = z + lz;
                                        if (Math.random() < 0.7 && Math.abs(lx) + Math.abs(ly) + Math.abs(lz) < 5) {
                                            blocks[`${leafX},${leafY},${leafZ}`] = { type: 'leaves' };
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log(`Generated terrain with ${Object.keys(blocks).length} blocks`);
                return blocks;
            }
            
            // Initialize the world with terrain
            initialBlocks = generateTerrain();
            updateWorld(initialBlocks);

            // Weather system
            const weatherTypes = {
                clear: { type: 'clear', particleCount: 0, color: 0xffffff },
                rain: { type: 'rain', particleCount: 1000, color: 0x99ccff },
                snow: { type: 'snow', particleCount: 500, color: 0xffffff }
            };
            
            let weatherParticles = [];
            
            function createWeatherParticles(weatherType) {
                // Remove old particles
                weatherParticles.forEach(particle => {
                    scene.remove(particle);
                });
                weatherParticles = [];
                
                if (weatherType === 'clear') return;
                
                const weather = weatherTypes[weatherType];
                const particleGeometry = new THREE.BufferGeometry();
                const particlePositions = [];
                
                // Create particles in a box above the player
                for (let i = 0; i < weather.particleCount; i++) {
                    const x = Math.random() * 100 - 50;
                    const y = Math.random() * 20 + 20;
                    const z = Math.random() * 100 - 50;
                    particlePositions.push(x, y, z);
                }
                
                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
                
                // Create material based on weather type
                const particleMaterial = new THREE.PointsMaterial({
                    color: weather.color,
                    size: weatherType === 'rain' ? 0.1 : 0.3,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);
                weatherParticles.push(particles);
                
                // Add particle animation to animate function
                const updateWeatherParticles = () => {
                    const positions = particleGeometry.attributes.position.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // Move particles down
                        positions[i + 1] -= weatherType === 'rain' ? 0.2 : 0.05;
                        
                        // If snow, add some horizontal movement
                        if (weatherType === 'snow') {
                            positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                            positions[i + 2] += Math.cos(Date.now() * 0.001 + i) * 0.01;
                        }
                        
                        // Reset particles that go below ground
                        if (positions[i + 1] < 0) {
                            positions[i] = Math.random() * 100 - 50 + camera.position.x;
                            positions[i + 1] = Math.random() * 20 + 20;
                            positions[i + 2] = Math.random() * 100 - 50 + camera.position.z;
                        }
                    }
                    
                    particleGeometry.attributes.position.needsUpdate = true;
                };
                
                return updateWeatherParticles;
            }
            
            // Function to change weather
            function changeWeather() {
                // Get the biome at the player's position
                const biome = getBiome(camera.position.x, camera.position.z);
                
                // Set weather based on biome and random chance
                const chance = Math.random();
                if (biome === 'Snowy Mountains') {
                    currentWeather = chance < 0.7 ? 'snow' : 'clear';
                } else if (biome === 'Mountains' || biome === 'Forest') {
                    currentWeather = chance < 0.3 ? 'rain' : 'clear';
                } else if (biome === 'Plains') {
                    currentWeather = chance < 0.2 ? 'rain' : 'clear';
                } else if (biome === 'Desert') {
                    currentWeather = 'clear';
            } else {
                    currentWeather = chance < 0.1 ? 'rain' : 'clear';
                }
                
                // Create weather particles
                weatherUpdateFunction = createWeatherParticles(currentWeather);
                
                // Show weather message
                addChatMessage(`Weather changed to ${currentWeather}!`, 'system-message');
                
                // Schedule next weather change
                setTimeout(changeWeather, 30000 + Math.random() * 60000);
            }
            
            // Initialize weather
            changeWeather();

            // Function to determine which water blocks are on top
            function updateWaterBlockStatus() {
                // First, mark all water blocks as not top
                Object.entries(waterBlocks).forEach(([posKey, block]) => {
                    block.userData.isTopWater = false;
                });
                
                // Then check each water block
                Object.entries(waterBlocks).forEach(([posKey, block]) => {
                    const [x, y, z] = posKey.split(',').map(Number);
                    const aboveKey = `${x},${y+1},${z}`;
                    
                    // If there's no water block above this one, it's a top water block
                    if (!waterBlocks[aboveKey]) {
                        block.userData.isTopWater = true;
                    }
                });
            }
            
            // Animation loop - main render function
            function animate() {
                requestAnimationFrame(animate);
                
                // Debug frame counter
                if (frameCount === undefined) {
                    frameCount = 0;
                }
                if (frameCount % 60 === 0) {
                    console.log('Frame:', frameCount, 'Camera position:', camera.position);
                }
                frameCount++;
                
                // Water animation - update every 30 frames (about twice per second)
                if (frameCount % 30 === 0) {
                    updateWaterBlockStatus(); // Check which water blocks are on top
                    updateWaterAnimation();   // Animate the top water blocks
                }
                
                // Apply gravity
                if (!playerPhysics.grounded) {
                    playerPhysics.velocity.y -= playerPhysics.gravity;
                    
                    // IMPORTANT: Add emergency transition for "stuck" states
                    // If in READY state but not grounded, force to FALLING
                    if (currentJumpState === jumpState.READY) {
                        currentJumpState = jumpState.FALLING;
                        console.log("STUCK STATE DETECTED: Forced READY → FALLING while in air");
                    }
                    
                    // Apply air friction/drag in the air
                    playerPhysics.velocity.x *= playerPhysics.airFriction;
                    playerPhysics.velocity.z *= playerPhysics.airFriction;
                } else {
                    // Apply friction when on the ground
                    playerPhysics.velocity.x *= playerPhysics.friction;
                    playerPhysics.velocity.z *= playerPhysics.friction;
                    
                    // IMPORTANT: Add emergency transition for "stuck" states
                    // If in JUMPING or FALLING but grounded, force to COOLDOWN
                    if (currentJumpState === jumpState.JUMPING || 
                        currentJumpState === jumpState.FALLING) {
                        currentJumpState = jumpState.COOLDOWN;
                        jumpCooldownTimer = 10;
                        console.log("STUCK STATE DETECTED: Forced to COOLDOWN while grounded");
                    }
                }
                
                // Update physics and controls
                if (isPointerLocked) {
                    // Update key mappings for browser consistency
                    updateKeyMappings();
                    
                    // Keep track of spacebar state for this frame
                    const spacebarPressed = keys['Space'] || keys['SpaceBar'];
                    
                    // Log key states periodically for debugging
                    if (frameCount % 60 === 0) {
                        console.log('Debug - Space:', spacebarPressed, 'Shift:', keys['Shift'], 'Grounded:', playerPhysics.grounded, 'Position Y:', camera.position.y);
                    }
                    
                    const moveVector = new THREE.Vector3();
                    let isMoving = false;
                    
                    // Check if player is actively moving
                    if (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD']) {
                        isMoving = true;
                    }

                    // Check for sprint (shift key) - now properly toggles when released
                    const isSprinting = keys['Shift'] || keys['ShiftLeft'] || keys['ShiftRight'];
                    const sprintMultiplier = isSprinting ? 3.0 : 1.0;
                    
                    // Calculate acceleration based on grounded state
                    const accel = playerPhysics.grounded ? 
                        playerPhysics.acceleration * sprintMultiplier : 
                        playerPhysics.acceleration * playerPhysics.airControl;
                    
                    // Apply movement forces
                    if (keys['KeyW']) moveVector.z -= accel;
                    if (keys['KeyS']) moveVector.z += accel;
                    if (keys['KeyA']) moveVector.x -= accel;
                    if (keys['KeyD']) moveVector.x += accel;
                    
                    // Extra logging when space is pressed
                    if (keys['Space'] || keys['SpaceBar']) {
                        console.log('Space pressed - State:', currentJumpState, 'Grounded:', playerPhysics.grounded, 'Y Pos:', camera.position.y.toFixed(2), 'Jump Flag:', jumpKeyWasPressed);
                    }
                    
                    // Handle jump cooldown
                    if (playerPhysics.jumpCooldown > 0) {
                        playerPhysics.jumpCooldown--;
                    }
                    
                    // =========== IMPROVED JUMP SYSTEM ===========
                    // Log jump state periodically
                    if (frameCount % 60 === 0) {
                        console.log('Jump Debug - State:', currentJumpState, 
                            'Grounded:', playerPhysics.grounded, 
                            'Key Pressed:', jumpKeyWasPressed,
                            'Key Released:', jumpKeyWasReleased,
                            'Y Vel:', playerPhysics.velocity.y.toFixed(3),
                            'Y Pos:', camera.position.y.toFixed(2));
                    }
                    
                    // Handle jump cooldown timer - reduce cooldown time
                    if (jumpCooldownTimer > 0) {
                        jumpCooldownTimer--;
                        if (jumpCooldownTimer === 0 && playerPhysics.grounded) {
                            currentJumpState = jumpState.READY;
                            console.log('Cooldown complete - Ready to jump');
                        }
                    }
                    
                    // Force transition to READY if player is trying to jump again while in COOLDOWN
                    // This prevents the anti-pogo system from blocking legitimate jumps
                    if (currentJumpState === jumpState.COOLDOWN && 
                        playerPhysics.grounded && 
                        spacebarPressed && 
                        jumpKeyWasReleased) {
                        currentJumpState = jumpState.READY;
                        jumpCooldownTimer = 0;
                        console.log("Force transition to READY state for jump attempt");
                    }
                    
                    // Update jump state based on velocity and grounded status
                    if (currentJumpState === jumpState.JUMPING && playerPhysics.velocity.y < 0) {
                        // Transition from jumping up to falling down
                        currentJumpState = jumpState.FALLING;
                        console.log('Peak of jump reached - Now falling. Y:', camera.position.y.toFixed(2));
                    }
                    else if (currentJumpState === jumpState.FALLING && playerPhysics.grounded) {
                        // Transition from falling to cooldown when landing
                        currentJumpState = jumpState.COOLDOWN;
                        jumpCooldownTimer = 5; // Reduced from 10 to 5 frames
                        console.log('Landed after jump - In cooldown. Y:', camera.position.y.toFixed(2));
                    }
                    
                    // Extra logging when space is pressed - use existing spacebarPressed variable
                    if (spacebarPressed) {
                        console.log('Space pressed - State:', currentJumpState, 'Grounded:', playerPhysics.grounded, 'Y Pos:', camera.position.y.toFixed(2), 'Jump Flag:', jumpKeyWasPressed);
                    }
                    
                    // Process jump input - CRITICAL FIX HERE
                    // Only jump if: 
                    // 1. In READY state 
                    // 2. On the ground
                    // 3. Space is pressed
                    // 4. Jump key was released since last jump
                    if (currentJumpState === jumpState.READY && 
                        playerPhysics.grounded && 
                        spacebarPressed && 
                        jumpKeyWasReleased) {
                        
                        // Apply jump force (ensure it's using the correct force)
                        playerPhysics.velocity.y = playerPhysics.jumpForce;
                        
                        // IMPORTANT: Update states in correct order
                        playerPhysics.grounded = false;  // No longer on ground
                        currentJumpState = jumpState.JUMPING;  // Now in jumping state
                        jumpKeyWasReleased = false;  // Consume the input - must release key before next jump
                        
                        console.log('JUMP EXECUTED! Force:', playerPhysics.jumpForce, 'Position:', camera.position.y.toFixed(2));
                        
                        // Play jump sound
                        sounds.playerJump.play();
                    }
                    
                    // Rotate move vector by camera rotation
                    moveVector.applyQuaternion(camera.quaternion);
                    
                    // Add to velocity
                    playerPhysics.velocity.x += moveVector.x;
                    playerPhysics.velocity.z += moveVector.z;
                    
                    // Clamp horizontal velocity to max speed
                    const horizSpeed = Math.sqrt(
                        playerPhysics.velocity.x * playerPhysics.velocity.x + 
                        playerPhysics.velocity.z * playerPhysics.velocity.z
                    );
                    
                    // Use sprint max speed when sprinting
                    const currentMaxSpeed = isSprinting ? playerPhysics.sprintMaxSpeed : playerPhysics.maxSpeed;
                    
                    if (horizSpeed > currentMaxSpeed) {
                        const ratio = currentMaxSpeed / horizSpeed;
                        playerPhysics.velocity.x *= ratio;
                        playerPhysics.velocity.z *= ratio;
                    }
                    
                    // Apply velocity to position
                    camera.position.add(playerPhysics.velocity);
                    
                    // Debug velocity
                    if (frameCount % 60 === 0 && horizSpeed > 0.01) {
                        console.log('Speed:', horizSpeed.toFixed(3), 'Vel:', 
                            playerPhysics.velocity.x.toFixed(3), 
                            playerPhysics.velocity.y.toFixed(3), 
                            playerPhysics.velocity.z.toFixed(3),
                            'Sprinting:', isSprinting);
                    }
                    
                    // Apply height limit - don't fall below 0
                    if (camera.position.y < playerPhysics.height / 2) {
                        camera.position.y = playerPhysics.height / 2;
                        playerPhysics.velocity.y = 0;
                        playerPhysics.grounded = true;
                    }
                }
                
                // Update player collisions
                handlePlayerCollisions();
                
                // ANTI-BOUNCE: Additional prevention after collisions are processed
                // Force vertical velocity to zero in these cases to prevent any bounce
                if (currentJumpState === jumpState.COOLDOWN || 
                   (playerPhysics.grounded && playerPhysics.velocity.y > 0)) {
                    
                    // This should never happen, but if it does, fix it
                    if (playerPhysics.velocity.y > 0) {
                        console.error("BOUNCE DETECTED! Forcing Y velocity to zero.", 
                            "State:", currentJumpState, 
                            "Y Vel:", playerPhysics.velocity.y.toFixed(3),
                            "Y Pos:", camera.position.y.toFixed(2));
                        playerPhysics.velocity.y = 0;
                    }
                }
                
                // SUPER ANTI-POGO: Check for unexpected position changes
                // But only if we're not currently attempting to jump
                const isJumpAttempt = (keys['Space'] || keys['SpaceBar']) && playerPhysics.grounded;
                
                if (playerPhysics.lastYPosition !== undefined && !isJumpAttempt) {
                    // If we're going up but not in JUMPING state, something's wrong
                    // Also increase the threshold to 0.05 to allow small movements
                    if (camera.position.y > playerPhysics.lastYPosition + 0.05 && 
                        currentJumpState !== jumpState.JUMPING) {
                        console.error("POGO DETECTED! Rising without being in JUMPING state!", 
                            "State:", currentJumpState, 
                            "Y change:", (camera.position.y - playerPhysics.lastYPosition).toFixed(3));
                        
                        // Fix: Force position back and velocity to zero
                        camera.position.y = playerPhysics.lastYPosition;
                        playerPhysics.velocity.y = 0;
                    }
                }
                
                // Store position for next frame comparison
                playerPhysics.lastYPosition = camera.position.y;
                
                // Update day/night cycle
                updateDayNight();
                
                // Update night objects visibility
                updateNightObjects();
                
                // Update lighting based on time of day
                updateLighting();
                
                // Update weather particles
                if (weatherUpdateFunction) {
                    weatherUpdateFunction();
                }
                
                // Update weather sounds
                updateWeatherSounds();
                
                // Update biome indicator
                updateBiomeIndicator();
                
                // Render the scene
                try {
                    renderer.render(scene, camera);
                    if (frameCount % 60 === 0) {
                        console.log('Render successful', frameCount);
                    }
                } catch (error) {
                    console.error('Render error:', error);
                }
            }
        });

        // Hotbar items
        const hotbarItems = [
            { type: 'grass', material: 'grass' },
            { type: 'dirt', material: 'dirt' },
            { type: 'stone', material: 'stone' },
            { type: 'wood', material: 'wood' },
            { type: 'leaves', material: 'leaves' },
            { type: 'sand', material: 'sand' },
            { type: 'water', material: 'water' },
            { type: 'lava', material: 'lava' },
            { type: 'glass', material: 'glass' },
            { type: 'brick', material: 'brick' },
            { type: 'cobblestone', material: 'cobblestone' },
            { type: 'iron_ore', material: 'iron_ore' },
            { type: 'diamond_ore', material: 'diamond_ore' },
            { type: 'redstone_dust', material: 'redstone_dust' },
            { type: 'redstone_torch', material: 'redstone_torch' },
            { type: 'redstone_block', material: 'redstone_block' },
            { type: 'redstone_lamp', material: 'redstone_lamp' },
            { type: 'redstone_repeater', material: 'redstone_repeater' },
            { type: 'redstone_comparator', material: 'redstone_comparator' }
        ];

        // Redstone power system
        const redstonePower = new Map();

        function updateRedstonePower(x, y, z) {
            const powerLevels = new Map();
            const visited = new Set();
            const queue = [];
            const repeaters = new Map();  // To track repeater states
            const comparators = new Map(); // To track comparator states

            // Initialize power levels
            blocks.forEach((block, key) => {
                if (block.type === 'redstone_block') {
                    powerLevels.set(key, 15);
                    queue.push(key);
                } else if (block.type === 'redstone_torch') {
                    // Check if torch should be active (not on a powered block)
                    const [tx, ty, tz] = key.split(',').map(Number);
                    const belowKey = `${tx},${ty-1},${tz}`;
                    const belowBlock = blocks.get(belowKey);
                    
                    // Torch is inactive if placed on a powered block
                    let isActive = true;
                    if (belowBlock && (belowBlock.type === 'redstone_block' || 
                                      (belowBlock.type === 'redstone_dust' && (powerLevels.get(belowKey) || 0) > 0))) {
                        isActive = false;
                        // Update the torch visual to be off
                        if (block.mesh && block.mesh.children && block.mesh.children[1]) {
                            block.mesh.children[1].material.emissive.setHex(0x400000);
                            block.mesh.children[1].material.emissiveIntensity = 0.2;
                        }
                        block.active = false;
                    } else {
                        // Torch is active, provide power
                        powerLevels.set(key, 15);
                        queue.push(key);
                        
                        // Update the torch visual to be on
                        if (block.mesh && block.mesh.children && block.mesh.children[1]) {
                            block.mesh.children[1].material.emissive.setHex(0xff0000);
                            block.mesh.children[1].material.emissiveIntensity = 1.0;
                        }
                        block.active = true;
                    }
                } else if (block.type === 'redstone_repeater') {
                    // Store repeater for later processing
                    repeaters.set(key, block);
                } else if (block.type === 'redstone_comparator') {
                    // Store comparator for later processing
                    comparators.set(key, block);
                } else {
                    powerLevels.set(key, 0);
                }
            });

            // Propagate power
            while (queue.length > 0) {
                const currentKey = queue.shift();
                if (visited.has(currentKey)) continue;
                visited.add(currentKey);

                const [cx, cy, cz] = currentKey.split(',').map(Number);
                const currentPower = powerLevels.get(currentKey);
                const currentBlock = blocks.get(currentKey);

                // Check adjacent blocks
                const directions = [
                    [1, 0, 0], [-1, 0, 0],
                    [0, 1, 0], [0, -1, 0],
                    [0, 0, 1], [0, 0, -1]
                ];

                for (const [dx, dy, dz] of directions) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    const nz = cz + dz;
                    const neighborKey = `${nx},${ny},${nz}`;
                    const neighbor = blocks.get(neighborKey);

                    if (!neighbor) continue;

                    let newPower = currentPower - 1;
                    if (newPower < 0) newPower = 0;

                    if (neighbor.type === 'redstone_dust') {
                        if (newPower > powerLevels.get(neighborKey)) {
                            powerLevels.set(neighborKey, newPower);
                            queue.push(neighborKey);
                        }
                    } else if (neighbor.type === 'redstone_lamp') {
                        const lamp = neighbor.mesh;
                        if (newPower > 0) {
                            lamp.material.emissive.setHex(0xff0000);
                            lamp.material.emissiveIntensity = 1.0;
                        } else {
                            lamp.material.emissive.setHex(0x000000);
                            lamp.material.emissiveIntensity = 0.0;
                        }
                    } else if (neighbor.type === 'redstone_repeater') {
                        // Check if this direction is the input side of the repeater
                        const repeaterDirection = neighbor.direction; // 0=north, 1=west, 2=south, 3=east
                        
                        // Determine if the current block is providing input to the repeater
                        let isInput = false;
                        
                        if ((repeaterDirection === 0 && dz === 1) ||  // Repeater facing north, input from south
                            (repeaterDirection === 1 && dx === 1) ||  // Repeater facing west, input from east
                            (repeaterDirection === 2 && dz === -1) || // Repeater facing south, input from north
                            (repeaterDirection === 3 && dx === -1)) { // Repeater facing east, input from west
                            isInput = true;
                        }
                        
                        if (isInput && newPower > 0) {
                            // Input torch on the repeater should light up immediately
                            const inputTorch = neighbor.mesh.children[1]; // The input torch
                            inputTorch.material.emissive.setHex(0xff0000);
                            inputTorch.material.emissiveIntensity = 1.0;
                            
                            // Only update the repeater if its powered state is changing
                            if (!neighbor.powered) {
                                neighbor.powered = true;
                                
                                // Clear any existing timer
                                if (neighbor.delayTimer) {
                                    clearTimeout(neighbor.delayTimer);
                                }
                                
                                // Delay the output based on repeater setting
                                neighbor.delayTimer = setTimeout(() => {
                                    // Output torch should light up after delay
                                    const outputTorch = neighbor.mesh.children[2]; // The output torch
                                    outputTorch.material.emissive.setHex(0xff0000);
                                    outputTorch.material.emissiveIntensity = 1.0;
                                    
                                    // Now the repeater is powering
                                    neighbor.powering = true;
                                    
                                    // Add output side to queue with full power (15)
                                    let outputX = nx, outputY = ny, outputZ = nz;
                                    
                                    if (repeaterDirection === 0) outputZ--;      // North
                                    else if (repeaterDirection === 1) outputX--;  // West
                                    else if (repeaterDirection === 2) outputZ++;  // South
                                    else if (repeaterDirection === 3) outputX++;  // East
                                    
                                    const outputKey = `${outputX},${outputY},${outputZ}`;
                                    const outputBlock = blocks.get(outputKey);
                                    
                                    if (outputBlock && outputBlock.type === 'redstone_dust') {
                                        powerLevels.set(outputKey, 15);  // Repeaters restore full signal strength
                                        queue.push(outputKey);
                                    }
                                    
                                }, neighbor.delay * 100); // Convert delay to milliseconds (1 tick = 100ms)
                            }
                        } else if (!isInput && newPower > 0) {
                            // Signal from non-input side doesn't power the repeater, but can power adjacent dust
                            if (neighbor.type === 'redstone_dust') {
                                if (newPower > powerLevels.get(neighborKey)) {
                                    powerLevels.set(neighborKey, newPower);
                                    queue.push(neighborKey);
                                }
                            }
                        }
                    } else if (neighbor.type === 'redstone_comparator') {
                        const comparatorDirection = neighbor.direction; // 0=north, 1=west, 2=south, 3=east
                        
                        // Determine if this is the input, left, or right side of the comparator
                        let inputSide = false;
                        let leftSide = false;
                        let rightSide = false;
                        
                        if ((comparatorDirection === 0 && dz === 1) ||  // Comparator facing north, input from south
                            (comparatorDirection === 1 && dx === 1) ||  // Comparator facing west, input from east
                            (comparatorDirection === 2 && dz === -1) || // Comparator facing south, input from north
                            (comparatorDirection === 3 && dx === -1)) { // Comparator facing east, input from west
                            inputSide = true;
                        } else if ((comparatorDirection === 0 && dx === 1) ||  // Comparator facing north, left from east
                                   (comparatorDirection === 1 && dz === -1) ||  // Comparator facing west, left from north
                                   (comparatorDirection === 2 && dx === -1) ||  // Comparator facing south, left from west
                                   (comparatorDirection === 3 && dz === 1)) {   // Comparator facing east, left from south
                            leftSide = true;
                        } else if ((comparatorDirection === 0 && dx === -1) ||  // Comparator facing north, right from west
                                   (comparatorDirection === 1 && dz === 1) ||    // Comparator facing west, right from south
                                   (comparatorDirection === 2 && dx === 1) ||    // Comparator facing south, right from east
                                   (comparatorDirection === 3 && dz === -1)) {   // Comparator facing east, right from north
                            rightSide = true;
                        }
                        
                        // Process input from different sides
                        if (inputSide) {
                            // Update main input power
                            if (newPower > 0) {
                                const inputTorch = neighbor.mesh.children[1]; // The input torch
                                inputTorch.material.emissive.setHex(0xff0000);
                                inputTorch.material.emissiveIntensity = 1.0;
                                
                                neighbor.powered = true;
                                neighbor.inputPower = newPower;
                            } else {
                                const inputTorch = neighbor.mesh.children[1]; // The input torch
                                inputTorch.material.emissive.setHex(0x000000);
                                inputTorch.material.emissiveIntensity = 0.0;
                                
                                neighbor.powered = false;
                                neighbor.inputPower = 0;
                            }
                        } else if (leftSide || rightSide) {
                            // Update side input power
                            if (newPower > neighbor.sideInputPower) {
                                neighbor.sideInputPower = newPower;
                                
                                // Update side torch visualization
                                const sideTorch = leftSide ? 
                                    neighbor.mesh.children[3] : // Left side torch
                                    neighbor.mesh.children[4];  // Right side torch
                                
                                sideTorch.material.emissive.setHex(0xff0000);
                                sideTorch.material.emissiveIntensity = newPower / 15.0; // Brightness based on power level
                            }
                        }
                        
                        // Calculate output power
                        let outputPower = 0;
                        
                        if (neighbor.powered) {
                            if (neighbor.comparisonMode) {
                                // Comparison mode: output full power if input >= side
                                outputPower = (neighbor.inputPower >= neighbor.sideInputPower) ? 
                                              neighbor.inputPower : 0;
                            } else {
                                // Subtraction mode: output input - side (min 0)
                                outputPower = Math.max(0, neighbor.inputPower - neighbor.sideInputPower);
                            }
                            
                            // Update output torch visualization
                            const outputTorch = neighbor.mesh.children[2]; // The output torch
                            
                            if (outputPower > 0) {
                                outputTorch.material.emissive.setHex(0xff0000);
                                outputTorch.material.emissiveIntensity = outputPower / 15.0; // Brightness based on power level
                            } else {
                                outputTorch.material.emissive.setHex(0x000000);
                                outputTorch.material.emissiveIntensity = 0.0;
                            }
                            
                            // If output power changed, update blocks after the comparator
                            if (outputPower !== neighbor.outputPower) {
                                neighbor.outputPower = outputPower;
                                
                                // Add output block to queue if power changed
                                let outputX = nx, outputY = ny, outputZ = nz;
                                
                                if (comparatorDirection === 0) outputZ--;      // North
                                else if (comparatorDirection === 1) outputX--;  // West
                                else if (comparatorDirection === 2) outputZ++;  // South
                                else if (comparatorDirection === 3) outputX++;  // East
                                
                                const outputKey = `${outputX},${outputY},${outputZ}`;
                                const outputBlock = blocks.get(outputKey);
                                
                                if (outputBlock && outputBlock.type === 'redstone_dust') {
                                    powerLevels.set(outputKey, outputPower);
                                    queue.push(outputKey);
                                }
                            }
                        }
                    }
                }
            }
            
            // Check for repeaters that need to turn off
            repeaters.forEach((repeater, key) => {
                const [rx, ry, rz] = key.split(',').map(Number);
                let inputX = rx, inputY = ry, inputZ = rz;
                
                // Determine input position based on direction
                if (repeater.direction === 0) inputZ++;      // Input from south
                else if (repeater.direction === 1) inputX++;  // Input from east
                else if (repeater.direction === 2) inputZ--;  // Input from north
                else if (repeater.direction === 3) inputX--;  // Input from west
                
                const inputKey = `${inputX},${inputY},${inputZ}`;
                const inputBlock = blocks.get(inputKey);
                
                let isPowered = false;
                
                // Check if the input block is powered
                if (inputBlock) {
                    if (inputBlock.type === 'redstone_block' || 
                        (inputBlock.type === 'redstone_torch' && inputBlock.active) ||
                        (inputBlock.type === 'redstone_dust' && (powerLevels.get(inputKey) || 0) > 0) ||
                        (inputBlock.type === 'redstone_repeater' && inputBlock.powering)) {
                        isPowered = true;
                    }
                }
                
                // Turn off repeater if input is no longer powered
                if (!isPowered && repeater.powered) {
                    repeater.powered = false;
                    
                    // Clear any existing timer
                    if (repeater.delayTimer) {
                        clearTimeout(repeater.delayTimer);
                        repeater.delayTimer = null;
                    }
                    
                    // Turn off input torch
                    const inputTorch = repeater.mesh.children[1]; // The input torch
                    inputTorch.material.emissive.setHex(0x000000);
                    inputTorch.material.emissiveIntensity = 0.0;
                    
                    // Turn off output torch
                    const outputTorch = repeater.mesh.children[2]; // The output torch
                    outputTorch.material.emissive.setHex(0x000000);
                    outputTorch.material.emissiveIntensity = 0.0;
                    
                    repeater.powering = false;
                    
                    // Update blocks affected by this repeater turning off
                    let outputX = rx, outputY = ry, outputZ = rz;
                    
                    if (repeater.direction === 0) outputZ--;      // North
                    else if (repeater.direction === 1) outputX--;  // West
                    else if (repeater.direction === 2) outputZ++;  // South
                    else if (repeater.direction === 3) outputX++;  // East
                    
                    updateRedstonePower(outputX, outputY, outputZ);
                }
            });
            
            // Process comparators to update their state
            comparators.forEach((comparator, key) => {
                // Reset side input power for next update
                comparator.sideInputPower = 0;
                
                // Calculate positions for input and side input blocks
                const [cx, cy, cz] = key.split(',').map(Number);
                let inputX = cx, inputY = cy, inputZ = cz;
                let leftX = cx, leftY = cy, leftZ = cz;
                let rightX = cx, rightY = cy, rightZ = cz;
                
                // Determine input and side input positions based on direction
                if (comparator.direction === 0) { // North
                    inputZ++;      // Input from south
                    leftX++;       // Left from east
                    rightX--;      // Right from west
                } else if (comparator.direction === 1) { // West
                    inputX++;      // Input from east
                    leftZ--;       // Left from north
                    rightZ++;      // Right from south
                } else if (comparator.direction === 2) { // South
                    inputZ--;      // Input from north
                    leftX--;       // Left from west
                    rightX++;      // Right from east
                } else if (comparator.direction === 3) { // East
                    inputX--;      // Input from west
                    leftZ++;       // Left from south
                    rightZ--;      // Right from north
                }
                
                // Check input power
                const inputKey = `${inputX},${inputY},${inputZ}`;
                const inputBlock = blocks.get(inputKey);
                
                let inputPower = 0;
                if (inputBlock) {
                    if (inputBlock.type === 'redstone_block') {
                        inputPower = 15;
                    } else if (inputBlock.type === 'redstone_torch' && inputBlock.active) {
                        inputPower = 15;
                    } else if (inputBlock.type === 'redstone_dust') {
                        inputPower = powerLevels.get(inputKey) || 0;
                    } else if (inputBlock.type === 'redstone_repeater' && inputBlock.powering) {
                        inputPower = 15;
                    } else if (inputBlock.type === 'redstone_comparator') {
                        inputPower = inputBlock.outputPower || 0;
                    }
                }
                
                // Check side inputs
                const leftKey = `${leftX},${leftY},${leftZ}`;
                const rightKey = `${rightX},${rightY},${rightZ}`;
                const leftBlock = blocks.get(leftKey);
                const rightBlock = blocks.get(rightKey);
                
                let leftPower = 0, rightPower = 0;
                
                if (leftBlock) {
                    if (leftBlock.type === 'redstone_block') {
                        leftPower = 15;
                    } else if (leftBlock.type === 'redstone_torch' && leftBlock.active) {
                        leftPower = 15;
                    } else if (leftBlock.type === 'redstone_dust') {
                        leftPower = powerLevels.get(leftKey) || 0;
                    } else if (leftBlock.type === 'redstone_repeater' && leftBlock.powering) {
                        leftPower = 15;
                    } else if (leftBlock.type === 'redstone_comparator') {
                        leftPower = leftBlock.outputPower || 0;
                    }
                }
                
                if (rightBlock) {
                    if (rightBlock.type === 'redstone_block') {
                        rightPower = 15;
                    } else if (rightBlock.type === 'redstone_torch' && rightBlock.active) {
                        rightPower = 15;
                    } else if (rightBlock.type === 'redstone_dust') {
                        rightPower = powerLevels.get(rightKey) || 0;
                    } else if (rightBlock.type === 'redstone_repeater' && rightBlock.powering) {
                        rightPower = 15;
                    } else if (rightBlock.type === 'redstone_comparator') {
                        rightPower = rightBlock.outputPower || 0;
                    }
                }
                
                // Update side input power (stronger of the two sides)
                comparator.sideInputPower = Math.max(leftPower, rightPower);
                
                // Update input torch visualization
                const inputTorch = comparator.mesh.children[1]; // The input torch
                if (inputPower > 0) {
                    inputTorch.material.emissive.setHex(0xff0000);
                    inputTorch.material.emissiveIntensity = inputPower / 15.0;
                    comparator.powered = true;
                    comparator.inputPower = inputPower;
                } else {
                    inputTorch.material.emissive.setHex(0x000000);
                    inputTorch.material.emissiveIntensity = 0.0;
                    comparator.powered = false;
                    comparator.inputPower = 0;
                }
                
                // Update side torch visualizations
                const leftTorch = comparator.mesh.children[3]; // Left side torch
                const rightTorch = comparator.mesh.children[4]; // Right side torch
                
                if (leftPower > 0) {
                    leftTorch.material.emissive.setHex(0xff0000);
                    leftTorch.material.emissiveIntensity = leftPower / 15.0;
                } else {
                    leftTorch.material.emissive.setHex(0x000000);
                    leftTorch.material.emissiveIntensity = 0.0;
                }
                
                if (rightPower > 0) {
                    rightTorch.material.emissive.setHex(0xff0000);
                    rightTorch.material.emissiveIntensity = rightPower / 15.0;
                } else {
                    rightTorch.material.emissive.setHex(0x000000);
                    rightTorch.material.emissiveIntensity = 0.0;
                }
                
                // Calculate output power based on mode
                let outputPower = 0;
                
                if (comparator.powered) {
                    if (comparator.comparisonMode) {
                        // Comparison mode: output full power if input >= side
                        outputPower = (comparator.inputPower >= comparator.sideInputPower) ? 
                                      comparator.inputPower : 0;
                    } else {
                        // Subtraction mode: output input - side (min 0)
                        outputPower = Math.max(0, comparator.inputPower - comparator.sideInputPower);
                    }
                }
                
                // Update output torch visualization
                const outputTorch = comparator.mesh.children[2]; // The output torch
                
                if (outputPower > 0) {
                    outputTorch.material.emissive.setHex(0xff0000);
                    outputTorch.material.emissiveIntensity = outputPower / 15.0;
                } else {
                    outputTorch.material.emissive.setHex(0x000000);
                    outputTorch.material.emissiveIntensity = 0.0;
                }
                
                // Check if output power changed
                if (outputPower !== comparator.outputPower) {
                    comparator.outputPower = outputPower;
                    
                    // Update block after the comparator if output power changed
                    let outputX = cx, outputY = cy, outputZ = cz;
                    
                    if (comparator.direction === 0) outputZ--;      // North
                    else if (comparator.direction === 1) outputX--;  // West
                    else if (comparator.direction === 2) outputZ++;  // South
                    else if (comparator.direction === 3) outputX++;  // East
                    
                    // Re-run power update for output area
                    updateRedstonePower(outputX, outputY, outputZ);
                }
            });
            
            // Propagate power
            while (queue.length > 0) {
                const currentKey = queue.shift();
                if (visited.has(currentKey)) continue;
                visited.add(currentKey);
                
                const [cx, cy, cz] = currentKey.split(',').map(Number);
                const currentPower = powerLevels.get(currentKey);
                
                // Check adjacent blocks
                const directions = [
                    [1, 0, 0], [-1, 0, 0],
                    [0, 1, 0], [0, -1, 0],
                    [0, 0, 1], [0, 0, -1]
                ];
                
                for (const [dx, dy, dz] of directions) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    const nz = cz + dz;
                    const neighborKey = `${nx},${ny},${nz}`;
                    const neighbor = blocks.get(neighborKey);
                    
                    if (!neighbor) continue;
                    
                    let newPower = currentPower - 1;
                    if (newPower < 0) newPower = 0;
                    
                    if (neighbor.type === 'redstone_dust') {
                        if (newPower > powerLevels.get(neighborKey)) {
                            powerLevels.set(neighborKey, newPower);
                            queue.push(neighborKey);
                        }
                    }
                }
            }
            
            return powerLevels.get(key) || 0;
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = blocks.get(key);
            if (!block) return;

            // Store block type before removal
            const blockType = block.type;

            scene.remove(block.mesh);
            blocks.delete(key);

            // Update redstone power if removing a redstone component
            if (blockType === 'redstone_block' || blockType === 'redstone_torch' || 
                blockType === 'redstone_dust' || blockType === 'redstone_lamp' ||
                blockType === 'redstone_repeater' || blockType === 'redstone_comparator') {
                updateRedstonePower(x, y, z);
            }
        }

        // Handle right-clicking on repeaters to change delay
        window.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            
            if (!selectedBlock) return;
            
            const { x, y, z } = selectedBlock;
            const key = `${x},${y},${z}`;
            const block = blocks.get(key);
            
            if (block && block.type === 'redstone_repeater') {
                // Cycle through delay settings (1, 2, 3, 4 ticks)
                block.delay = (block.delay % 4) + 1;
                
                // Update the visual representation of the delay
                const delayLever = block.mesh.children[3]; // The delay lever
                
                // Move the lever based on delay setting
                const leverPositions = [
                    new THREE.Vector3(0, -0.27, 0),      // delay 1
                    new THREE.Vector3(0.1, -0.27, 0),    // delay 2
                    new THREE.Vector3(0.2, -0.27, 0),    // delay 3
                    new THREE.Vector3(0.3, -0.27, 0)     // delay 4
                ];
                
                delayLever.position.copy(leverPositions[block.delay - 1]);
                
                // Show a message to the player
                addChatMessage('system', `Repeater delay set to ${block.delay} tick${block.delay > 1 ? 's' : ''}`);
            } else if (block && block.type === 'redstone_comparator') {
                // Toggle between comparison and subtraction modes
                block.comparisonMode = !block.comparisonMode;
                
                // Update the visual representation of the mode
                const modeLever = block.mesh.children[5]; // The mode lever
                
                if (block.comparisonMode) {
                    // Move lever forward to indicate comparison mode
                    modeLever.position.set(0.2, -0.23, 0);
                    addChatMessage('system', 'Comparator set to comparison mode');
                } else {
                    // Move lever back to indicate subtraction mode
                    modeLever.position.set(0.1, -0.23, 0);
                    addChatMessage('system', 'Comparator set to subtraction mode');
                }
                
                // Update power calculation with new mode
                updateRedstonePower(x, y, z);
            }
        });

        function placeBlock(x, y, z, type, material) {
            const key = `${x},${y},${z}`;
            if (blocks.has(key)) return;

            let block;
            
            if (type === 'redstone_torch') {
                // ... existing torch code ...
            } else if (type === 'redstone_repeater') {
                // ... existing repeater code ...
            } else if (type === 'redstone_comparator') {
                // Create custom geometry for redstone comparator
                const baseGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE / 4, BLOCK_SIZE);
                const torchGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8);
                const modeLeverGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.15);
                
                // Create materials
                const baseMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xCCCCCC,  // Light gray color for base
                    roughness: 0.7,
                    metalness: 0.0
                });
                
                const torchMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,  // Red color
                    emissive: 0x000000,  // Start off
                    emissiveIntensity: 0.0,
                    roughness: 0.5,
                    metalness: 0.0
                });
                
                const leverMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,  // Brown color for mode lever
                    roughness: 0.7,
                    metalness: 0.0
                });
                
                // Create meshes
                const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
                const inputTorchMesh = new THREE.Mesh(torchGeometry, torchMaterial.clone());
                const outputTorchMesh = new THREE.Mesh(torchGeometry, torchMaterial.clone());
                const leftInputTorchMesh = new THREE.Mesh(torchGeometry, torchMaterial.clone());
                const rightInputTorchMesh = new THREE.Mesh(torchGeometry, torchMaterial.clone());
                const modeLeverMesh = new THREE.Mesh(modeLeverGeometry, leverMaterial);
                
                // Position the components
                baseMesh.position.y = -0.38;  // Lower the base
                
                // Position torches and lever
                inputTorchMesh.position.set(-0.3, -0.23, 0);      // Back torch (input)
                outputTorchMesh.position.set(0.3, -0.23, 0);      // Front torch (output)
                leftInputTorchMesh.position.set(0, -0.23, -0.25); // Left side input
                rightInputTorchMesh.position.set(0, -0.23, 0.25); // Right side input
                modeLeverMesh.position.set(0.1, -0.23, 0);        // Mode lever
                
                // Create a group to hold all parts
                const comparatorGroup = new THREE.Group();
                comparatorGroup.add(baseMesh);
                comparatorGroup.add(inputTorchMesh);
                comparatorGroup.add(outputTorchMesh);
                comparatorGroup.add(leftInputTorchMesh);
                comparatorGroup.add(rightInputTorchMesh);
                comparatorGroup.add(modeLeverMesh);
                
                // Apply proper rotation based on player's orientation
                let rotation = 0;
                if (playerDirection.x > 0.5) {
                    rotation = -Math.PI / 2;  // facing east
                } else if (playerDirection.x < -0.5) {
                    rotation = Math.PI / 2;   // facing west
                } else if (playerDirection.z > 0.5) {
                    rotation = 0;             // facing north
                } else if (playerDirection.z < -0.5) {
                    rotation = Math.PI;       // facing south
                }
                
                comparatorGroup.rotation.y = rotation;
                
                // Position the comparator in the center of the block
                comparatorGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
                scene.add(comparatorGroup);
                
                // Initialize comparator state
                block = { 
                    type, 
                    material, 
                    mesh: comparatorGroup, 
                    direction: Math.round(rotation / (Math.PI / 2)) % 4,  // 0=north, 1=west, 2=south, 3=east
                    powered: false,
                    outputPower: 0,
                    comparisonMode: false,    // false = subtraction mode, true = comparison mode
                    inputPower: 0,
                    sideInputPower: 0
                };
            } else {
                // ... existing regular block code ...
            }

            blocks.set(key, block);

            // Update redstone power if placing a redstone component
            if (type === 'redstone_block' || type === 'redstone_torch' || 
                type === 'redstone_dust' || type === 'redstone_lamp' ||
                type === 'redstone_repeater' || type === 'redstone_comparator') {
                updateRedstonePower(x, y, z);
            }
        }
    </script>
</body>
</html> 