<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craftverse</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 100vh;
            width: 100vw;
            z-index: 0;
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        h1 {
            color: #2c3e50;
        }
        p {
            color: #34495e;
            line-height: 1.6;
        }
        #players {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        #chat {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        .player {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            min-width: 150px;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .connected {
            background: #d4edda;
            color: #155724;
        }
        .disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        #controls {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .control-btn {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
        .control-btn:hover {
            background: #0056b3;
        }
        .control-btn.active {
            background: #28a745;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        .chat-message {
            text-align: left;
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .system-message {
            background: #e9ecef;
            color: #6c757d;
        }
        .player-message {
            background: #e3f2fd;
            color: #1976d2;
        }
        #chat-input {
            display: flex;
            gap: 10px;
        }
        #message-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        #send-message {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #send-message:hover {
            background: #218838;
        }
        #inventory {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .inventory-slot {
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }
        .inventory-slot.selected {
            background: #007bff;
            color: white;
        }
        .inventory-slot img {
            width: 32px;
            height: 32px;
        }
        .block-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
        }
        #block-info {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .movement-mode {
            margin-top: 10px;
            padding: 5px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .movement-mode button {
            margin: 0 5px;
            padding: 5px 10px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .movement-mode button.active {
            background: #28a745;
        }

        /* Block breaking animation */
        .block-breaking {
            position: relative;
            overflow: hidden;
        }
        .block-breaking::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            animation: breaking 1s linear forwards;
        }
        @keyframes breaking {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Player animations */
        .player {
            transition: transform 0.2s ease;
        }
        .player.walking {
            animation: walk 0.5s infinite;
        }
        .player.running {
            animation: run 0.3s infinite;
        }
        .player.crouching {
            transform: scale(0.8);
        }
        .player.jumping {
            animation: jump 0.5s ease;
        }
        @keyframes walk {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        @keyframes run {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        @keyframes jump {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        /* Block preview */
        .block-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 64px;
            height: 64px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            pointer-events: none;
            display: none;
        }
        .block-preview.visible {
            display: block;
        }

        /* Block breaking progress */
        .breaking-progress {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            display: none;
        }
        .breaking-progress.visible {
            display: block;
        }
        .breaking-progress-bar {
            width: 0%;
            height: 100%;
            background: #28a745;
            border-radius: 10px;
            transition: width 0.1s linear;
        }

        /* Enhanced inventory system */
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #666;
        }
        .hotbar-slot.selected {
            border-color: #fff;
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 12px;
        }
        .inventory-slot {
            position: relative;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
        }
        .inventory-slot img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Durability bar styles */
        .durability-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 2px;
            background: #00ff00;
            transition: width 0.2s;
        }
        .durability-bar[style*="width: 0%"] {
            background: #ff0000;
        }

        .chat-message {
            margin: 5px 0;
            padding: 5px;
            border-radius: 5px;
        }

        .player-message {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .system-message {
            background-color: rgba(255, 255, 0, 0.1);
            color: #ffd700;
        }

        #playerList {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }

        .player {
            margin: 5px 0;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .player h3 {
            margin: 0;
            font-size: 14px;
        }

        .player p {
            margin: 2px 0;
            font-size: 12px;
            color: #ccc;
        }

        #status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
        }

        .connected {
            background-color: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        .disconnected {
            background-color: rgba(255, 0, 0, 0.3);
            color: #ff0000;
        }

        .recipe {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .recipe h3 {
            margin: 0 0 10px 0;
            color: #ffd700;
        }
        
        .recipe p {
            margin: 5px 0;
        }
        
        .craft-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }
        
        .craft-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        #recipes-list {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Game Settings Panel */
        #game-settings {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 1000;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            transition: opacity 0.3s ease;
        }

        #game-settings.visible {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .settings-group {
            margin-bottom: 15px;
        }

        .settings-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .settings-option {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .settings-option label {
            margin-right: 10px;
        }

        .settings-option input[type="range"] {
            width: 150px;
        }

        .settings-option input[type="checkbox"] {
            margin-right: 5px;
        }

        /* Improved UI Styling */
        #ui-container > * {
            pointer-events: auto;
        }

        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }

        #players {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            max-width: 200px;
        }

        #chat {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            width: 300px;
        }

        #chat-messages {
            height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #chat-input {
            display: flex;
            gap: 5px;
        }

        #message-input {
            flex: 1;
            padding: 5px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        #send-message {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        #send-message:hover {
            background: #45a049;
        }

        .chat-message {
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }

        .chat-message.system-message {
            color: #4CAF50;
            font-style: italic;
        }

        .chat-message.player-message {
            color: #fff;
        }

        .chat-message .player-name {
            color: #4CAF50;
            font-weight: bold;
        }

        /* Settings Button */
        #settings-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #4CAF50;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1001;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #settings-button:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #settings-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div id="ui-container">
        <div id="status">Status: Connecting...</div>

        <button id="settings-button">
            <svg viewBox="0 0 24 24">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
            </svg>
            Settings
        </button>

        <div id="game-settings">
            <div class="settings-group">
                <h3>Graphics</h3>
                <div class="settings-option">
                    <label>Render Distance:</label>
                    <input type="range" id="render-distance" min="1" max="10" value="5">
                </div>
                <div class="settings-option">
                    <label>Particles:</label>
                    <input type="checkbox" id="particles-enabled" checked>
                </div>
            </div>
            <div class="settings-group">
                <h3>Gameplay</h3>
                <div class="settings-option">
                    <label>Mouse Sensitivity:</label>
                    <input type="range" id="mouse-sensitivity" min="0.1" max="2" step="0.1" value="1">
                </div>
                <div class="settings-option">
                    <label>Auto-Save:</label>
                    <input type="checkbox" id="auto-save" checked>
                </div>
            </div>
            <div class="settings-group">
                <h3>Audio</h3>
                <div class="settings-option">
                    <label>Master Volume:</label>
                    <input type="range" id="master-volume" min="0" max="1" step="0.1" value="0.5">
                </div>
                <div class="settings-option">
                    <label>Sound Effects:</label>
                    <input type="checkbox" id="sound-effects" checked>
                </div>
            </div>
            <div class="settings-group">
                <h3>Performance</h3>
                <div class="settings-option">
                    <label>FPS Limit:</label>
                    <input type="range" id="fps-limit" min="30" max="144" step="1" value="60">
                </div>
                <div class="settings-option">
                    <label>VSync:</label>
                    <input type="checkbox" id="vsync-enabled">
                </div>
            </div>
        </div>

        <div id="players">
            <h2>Connected Players</h2>
            <div id="playerList"></div>
        </div>

        <div id="chat">
            <h2>Chat</h2>
            <div id="chat-messages"></div>
            <div id="chat-input">
                <input type="text" id="message-input" placeholder="Type a message...">
                <button id="send-message">Send</button>
            </div>
        </div>
    </div>

    <div class="block-preview" id="block-preview"></div>
    <div class="breaking-progress" id="breaking-progress">
        <div class="breaking-progress-bar"></div>
    </div>
    
    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Performance monitoring without using unload events
            // This avoids the deprecated "Unload event listeners" warning
            if (window.performance) {
                console.log('Performance API available');
                
                // Use visibilitychange instead of unload/beforeunload
                document.addEventListener('visibilitychange', function() {
                    if (document.visibilityState === 'hidden') {
                        console.log('Page is being hidden, saving state...');
                        // Save game state or perform cleanup here
                    }
                });
            }

            // At the top of your script section, add:
            const simplex = new SimplexNoise();
            
            // Mock socket for offline mode
            const socket = {
                emit: () => {},
                on: () => {},
                connected: false
            };

            // Create temporary status UI for offline mode
            const status = document.createElement('div');
            status.id = 'status';
            status.style.position = 'fixed';
            status.style.top = '10px';
            status.style.left = '10px';
            status.style.padding = '5px 10px';
            status.style.background = 'rgba(0, 0, 0, 0.5)';
            status.style.color = 'white';
            status.style.borderRadius = '5px';
            document.body.appendChild(status);

            // Initialize in offline mode
            status.textContent = 'Status: Offline Mode';

            // Function to add chat messages - defined early to be used anywhere
            function addChatMessage(message, type = 'player-message') {
                console.log(`${type}: ${message}`);
                
                // If chat UI exists, use it
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const messageElement = document.createElement('div');
                    messageElement.className = `chat-message ${type}`;
                    messageElement.textContent = message;
                    messageElement.style.marginBottom = '5px';
                    messageElement.style.padding = '5px';
                    messageElement.style.borderRadius = '3px';
                    
                    if (type === 'system-message') {
                        messageElement.style.color = '#ffcc00';
                    } else {
                        messageElement.style.color = 'white';
                    }
                    
                    chatMessages.appendChild(messageElement);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }

            // Initialize Three.js
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Create renderer with canvas
            const canvas = document.getElementById('game-canvas');
            console.log('Game canvas element:', canvas);
            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: false 
            });
            
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB, 1);  // Sky blue background
            
            // Force the renderer to be visible
            canvas.style.display = 'block';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '10';
            
            console.log('Renderer initialized', renderer);
            
            // Check for WebGL support
            if (!renderer.capabilities.isWebGL2) {
                console.warn('WebGL 2 not supported, using WebGL 1');
            }
            
            if (!renderer.context) {
                console.error('No WebGL context - rendering will fail!');
                // Show an error message to the user
                addChatMessage('ERROR: WebGL not supported by your browser. The game will not render properly.', 'system-message');
            } else {
                console.log('WebGL context found:', renderer.context);
            }

            // Add window resize handler
            window.addEventListener('resize', function() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // Update renderer and camera
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                
                console.log('Window resized', width, height);
            });
            
            // Add more visible debug objects
            // Create a grid helper for perspective
            const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x888888);
            scene.add(gridHelper);
            
            // Create some colorful boxes at different positions
            const createColorfulBox = (x, y, z, color) => {
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshStandardMaterial({ color: color });
                const box = new THREE.Mesh(geometry, material);
                box.position.set(x, y, z);
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
                return box;
            };
            
            // Create multiple boxes in different colors
            createColorfulBox(-10, 1, -10, 0xff0000); // Red
            createColorfulBox(10, 1, -10, 0x00ff00);  // Green
            createColorfulBox(-10, 1, 10, 0x0000ff);  // Blue
            createColorfulBox(10, 1, 10, 0xffff00);   // Yellow

            // Game constants
            const CHUNK_SIZE = 16;
            const BLOCK_SIZE = 1;
            const CHUNK_HEIGHT = 256;
            let currentWeather = 'clear';
            let frameCount = 0;  // Add frame counter variable

            // Sound manager
            const soundManager = {
                volume: 0.5,
                weatherVolume: 0.3,
                effectsVolume: 0.8,
                musicVolume: 0.6,
                muted: false
            };
            
            // Sound system - create dummy audio objects to prevent 404 errors
            const createDummyAudio = () => {
                const audio = new Audio();
                // Don't set src to prevent 404 errors
                audio.play = function() { 
                    // Don't return a promise
                    return undefined; 
                };
                audio.pause = function() {
                    // Empty function
                };
                // Add paused property
                audio.paused = true;
                return audio;
            };

            const sounds = {
                blockBreak: createDummyAudio(),
                blockPlace: createDummyAudio(),
                playerWalk: createDummyAudio(),
                playerJump: createDummyAudio(),
                playerLand: createDummyAudio(),
                inventoryOpen: createDummyAudio(),
                inventoryClose: createDummyAudio(),
                crafting: createDummyAudio(),
                weatherRain: createDummyAudio(),
                weatherSnow: createDummyAudio(),
                swordSwing: createDummyAudio()
            };
            
            // Function to get biome based on position
            function getBiome(x, z) {
                // Sample noise at lower frequency for biome detection
                const biomeNoise = simplex.noise2D(x * 0.01, z * 0.01);
                
                if (biomeNoise < -0.6) {
                    return 'Snowy Mountains';
                } else if (biomeNoise < -0.3) {
                    return 'Mountains';
                } else if (biomeNoise < -0.1) {
                    return 'Forest';
                } else if (biomeNoise < 0.2) {
                    return 'Plains';
                } else if (biomeNoise < 0.5) {
                    return 'Desert';
                } else {
                    return 'Beach';
                }
            }

            // Function to update the block preview
            function updateBlockPreview(positionKey) {
                const blockPreview = document.getElementById('block-preview');
                if (blockPreview) {
                    blockPreview.classList.add('visible');
                    // Parse position from the position key
                    const [x, y, z] = positionKey.split(',').map(Number);
                    // You can add more visualization logic here if needed
                }
            }

            // Function to hide the block preview
            function hideBlockPreview() {
                const blockPreview = document.getElementById('block-preview');
                if (blockPreview) {
                    blockPreview.classList.remove('visible');
                }
            }

            // Add skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);

            // Add sun
            const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(50, 50, 50);
            scene.add(sun);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Add ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a9d23,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);

            // Block materials
            const blockMaterials = {
                grass: new THREE.MeshStandardMaterial({ color: 0x3a9d23 }),
                dirt: new THREE.MeshStandardMaterial({ color: 0x8b4513 }),
                stone: new THREE.MeshStandardMaterial({ color: 0x808080 }),
                wood: new THREE.MeshStandardMaterial({ color: 0x8b4513 }),
                leaves: new THREE.MeshStandardMaterial({ color: 0x2d5a27 }),
                sand: new THREE.MeshStandardMaterial({ color: 0xc2b280 }),
                water: new THREE.MeshStandardMaterial({ 
                    color: 0x0077be,
                    transparent: true,
                    opacity: 0.6
                }),
                lava: new THREE.MeshStandardMaterial({ color: 0xff4500 }),
                glass: new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3
                }),
                brick: new THREE.MeshStandardMaterial({ color: 0xb22222 }),
                snow: new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.3
                })
            };

            // Block geometries
            const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            let blockMeshes = {};
            let selectedBlock = null;

            // Camera position - move it higher and further back
            camera.position.set(0, 5, 30);  // Move further back to see more
            camera.lookAt(0, 0, 0);
            
            console.log('Camera positioned at:', camera.position);

            // Add a debug box to make sure something is visible
            const debugBoxGeometry = new THREE.BoxGeometry(5, 5, 5);
            const debugBoxMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const debugBox = new THREE.Mesh(debugBoxGeometry, debugBoxMaterial);
            debugBox.position.set(0, 0, 0);
            scene.add(debugBox);

            // Mouse controls
            let isPointerLocked = false;
            const moveSpeed = 0.1;
            const keys = {};

            // Add raycaster for block interaction
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            document.addEventListener('click', (event) => {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                } else {
                    // Calculate mouse position in normalized device coordinates
                    mouse.x = 0; // Center of screen
                    mouse.y = 0; // Center of screen

                    // Update raycaster
                    raycaster.setFromCamera(mouse, camera);

                    // Find intersected blocks
                    const intersects = raycaster.intersectObjects(Object.values(blockMeshes));
                    
                    if (intersects.length > 0) {
                        const intersect = intersects[0];
                        const mesh = intersect.object;
                        const position = mesh.position.clone();
                        const positionKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;
                        
                        // Left click - Break block
                        if (event.button === 0) {
                            // Remove block
                            sounds.blockBreak.play();
                            scene.remove(mesh);
                            delete blockMeshes[positionKey];
                            delete initialBlocks[positionKey];
                        }
                        // Right click - Place block
                        else if (event.button === 2 && selectedBlock) {
                            // Calculate position for new block
                            const normal = intersect.face.normal;
                            const newPosition = position.clone().add(normal);
                            const newPositionKey = `${Math.round(newPosition.x)},${Math.round(newPosition.y)},${Math.round(newPosition.z)}`;
                            
                            // Check if position is already occupied
                            if (!blockMeshes[newPositionKey]) {
                                // Create new block
                                sounds.blockPlace.play();
                                const mesh = new THREE.Mesh(blockGeometry, blockMaterials[selectedBlock]);
                                mesh.position.copy(newPosition);
                                mesh.castShadow = true;
                                mesh.receiveShadow = true;
                                scene.add(mesh);
                                blockMeshes[newPositionKey] = mesh;
                                initialBlocks[newPositionKey] = { type: selectedBlock };
                            }
                        }
                    }
                }
            });
            
            // Prevent context menu
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Add crosshair to center of screen
            const crosshair = document.createElement('div');
            crosshair.id = 'crosshair';
            crosshair.style.position = 'fixed';
            crosshair.style.top = '50%';
            crosshair.style.left = '50%';
            crosshair.style.transform = 'translate(-50%, -50%)';
            crosshair.style.width = '10px';
            crosshair.style.height = '10px';
            crosshair.style.borderRadius = '50%';
            crosshair.style.border = '2px solid white';
            crosshair.style.pointerEvents = 'none';
            document.body.appendChild(crosshair);

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    
                    // Update raycaster for block preview
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(Object.values(blockMeshes));
                    
                    if (intersects.length > 0) {
                        const intersect = intersects[0];
                        const normal = intersect.face.normal;
                        const position = intersect.object.position.clone();
                        const newPosition = position.clone().add(normal);
                        
                        // Update crosshair color based on interaction
                        if (selectedBlock) {
                            crosshair.style.borderColor = 'lime'; // Place mode
                        } else {
                            crosshair.style.borderColor = 'red';  // Break mode
                        }
                    } else {
                        // Reset crosshair if not pointing at a block
                        crosshair.style.borderColor = 'white';
                    }
                }
            });

            // Update world
            function updateWorld(world) {
                // Remove old blocks
                Object.values(blockMeshes).forEach(mesh => {
                    scene.remove(mesh);
                });
                blockMeshes = {};

                // Add new blocks - handle both formats
                const blocksToProcess = world.blocks || world;
                
                Object.entries(blocksToProcess).forEach(([position, block]) => {
                    const [x, y, z] = position.split(',').map(Number);
                    const mesh = new THREE.Mesh(blockGeometry, blockMaterials[block.type]);
                    mesh.position.set(x, y, z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    blockMeshes[position] = mesh;
                });
            }

            // Set initial player state
            let currentPlayer = {
                id: 'local-player',
                position: { x: 0, y: 2, z: 5 },
                health: 100,
                inventory: {
                    grass: 64,
                    dirt: 64,
                    stone: 64,
                    wood: 64,
                    leaves: 64,
                    sand: 64
                }
            };

            // Player idle animation
            let idleTime = 0;
            const idleAnimation = () => {
                idleTime += 0.02;
                if (!keys['KeyW'] && !keys['KeyS'] && !keys['KeyA'] && !keys['KeyD']) {
                    const playerElement = document.getElementById(`player-${currentPlayer.id}`);
                    if (playerElement) {
                        playerElement.style.transform = `translateY(${Math.sin(idleTime) * 2}px)`;
                    }
                }
            };

            // Day/night cycle
            const dayNight = {
                timeOfDay: 0, // 0 to 1, where 0 is dawn
                dayLength: 1200000, // 20 minutes in milliseconds
                lastTime: Date.now(),
                sun: new THREE.DirectionalLight(0xffffff, 1),
                moon: new THREE.DirectionalLight(0x404040, 0.5),
                skyColor: new THREE.Color(0x87CEEB), // Sky blue
                nightColor: new THREE.Color(0x000033), // Dark blue
                fog: new THREE.Fog(0x87CEEB, 20, 100)
            };

            // Initialize day/night cycle
            function initDayNight() {
                // Add sun and moon
                dayNight.sun.position.set(50, 50, 50);
                dayNight.sun.castShadow = true;
                dayNight.sun.shadow.mapSize.width = 2048;
                dayNight.sun.shadow.mapSize.height = 2048;
                scene.add(dayNight.sun);

                dayNight.moon.position.set(-50, 50, -50);
                dayNight.moon.castShadow = true;
                dayNight.moon.shadow.mapSize.width = 2048;
                dayNight.moon.shadow.mapSize.height = 2048;
                scene.add(dayNight.moon);

                // Add sky color
                scene.background = dayNight.skyColor;
                scene.fog = dayNight.fog;
            }

            // Update day/night cycle
            function updateDayNight() {
                const currentTime = Date.now();
                const deltaTime = currentTime - dayNight.lastTime;
                dayNight.timeOfDay = (dayNight.timeOfDay + deltaTime / dayNight.dayLength) % 1;
                dayNight.lastTime = currentTime;

                // Calculate sun and moon positions
                const sunAngle = dayNight.timeOfDay * Math.PI * 2;
                dayNight.sun.position.x = Math.cos(sunAngle) * 50;
                dayNight.sun.position.z = Math.sin(sunAngle) * 50;
                dayNight.moon.position.x = -Math.cos(sunAngle) * 50;
                dayNight.moon.position.z = -Math.sin(sunAngle) * 50;

                // Update lighting intensity
                const isNight = dayNight.timeOfDay > 0.5;
                dayNight.sun.intensity = isNight ? 0.1 : 1;
                dayNight.moon.intensity = isNight ? 0.5 : 0.1;

                // Update sky color
                const skyColor = new THREE.Color();
                if (isNight) {
                    skyColor.lerpColors(dayNight.skyColor, dayNight.nightColor, (dayNight.timeOfDay - 0.5) * 2);
                } else {
                    skyColor.lerpColors(dayNight.nightColor, dayNight.skyColor, dayNight.timeOfDay * 2);
                }
                scene.background = skyColor;
                scene.fog.color = skyColor;

                // Update fog density based on time of day
                scene.fog.density = isNight ? 0.05 : 0.02;
            }

            // Update night objects visibility
            function updateNightObjects() {
                const isNight = dayNight.timeOfDay > 0.5;
                
                // Check both moons (direct moon object and dayNight.moon)
                if (typeof moon !== 'undefined') {
                    moon.visible = isNight;
                }
                
                if (typeof dayNight !== 'undefined' && dayNight.moon) {
                    dayNight.moon.visible = isNight;
                }
                
                // Only try to update stars if they exist
                if (typeof stars !== 'undefined' && stars.length > 0) {
                    stars.forEach(star => {
                        star.visible = isNight;
                    });
                }
            }

            // Update lighting intensity
            function updateLighting() {
                let intensity;
                if (dayNight.timeOfDay < 0.25) {
                    // Dawn to noon
                    intensity = 0.6 + (dayNight.timeOfDay * 4) * 0.4;
                } else if (dayNight.timeOfDay < 0.5) {
                    // Noon to dusk
                    intensity = 1 - ((dayNight.timeOfDay - 0.25) * 4) * 0.4;
                } else if (dayNight.timeOfDay < 0.75) {
                    // Dusk to night
                    intensity = 0.6 - ((dayNight.timeOfDay - 0.5) * 4) * 0.6;
                } else {
                    // Night to dawn
                    intensity = 0 + ((dayNight.timeOfDay - 0.75) * 4) * 0.6;
                }
                ambientLight.intensity = intensity * 0.6;
                directionalLight.intensity = intensity;
            }

            // Function to update biome indicator
            function updateBiomeIndicator() {
                // Get current biome based on player position
                const biomeIndicator = document.getElementById('biome-indicator');
                if (biomeIndicator) {
                    const x = Math.floor(camera.position.x);
                    const z = Math.floor(camera.position.z);
                    const biome = getBiome(x, z);
                    biomeIndicator.textContent = `Biome: ${biome}`;
                }
            }

            // Update weather sounds
            function updateWeatherSounds() {
                if (currentWeather === 'rain') {
                    if (sounds.weatherRain.paused) {
                        sounds.weatherRain.volume = soundManager.volume * soundManager.weatherVolume;
                        sounds.weatherRain.loop = true;
                        sounds.weatherRain.play();
                    }
                } else {
                    sounds.weatherRain.pause();
                }

                if (currentWeather === 'snow') {
                    if (sounds.weatherSnow.paused) {
                        sounds.weatherSnow.volume = soundManager.volume * soundManager.weatherVolume;
                        sounds.weatherSnow.loop = true;
                        sounds.weatherSnow.play();
                    }
                } else {
                    sounds.weatherSnow.pause();
                }
            }

            // Initialize inventory
            function initializeInventory() {
                // Create inventory UI if it doesn't exist
                if (!document.getElementById('inventory-container')) {
                    const inventoryContainer = document.createElement('div');
                    inventoryContainer.id = 'inventory-container';
                    inventoryContainer.style.display = 'none';
                    inventoryContainer.style.position = 'fixed';
                    inventoryContainer.style.top = '50%';
                    inventoryContainer.style.left = '50%';
                    inventoryContainer.style.transform = 'translate(-50%, -50%)';
                    inventoryContainer.style.background = 'rgba(0, 0, 0, 0.8)';
                    inventoryContainer.style.padding = '20px';
                    inventoryContainer.style.borderRadius = '10px';
                    inventoryContainer.style.zIndex = '1000';
                    
                    inventoryContainer.innerHTML = `
                        <h2>Inventory</h2>
                        <div id="inventory-grid" class="inventory-grid"></div>
                        <div id="hotbar" class="hotbar"></div>
                        <button id="close-inventory">Close</button>
                    `;
                    document.body.appendChild(inventoryContainer);
                    
                    // Add hotbar to UI
                    const hotbarContainer = document.createElement('div');
                    hotbarContainer.id = 'hotbar-container';
                    hotbarContainer.style.position = 'fixed';
                    hotbarContainer.style.bottom = '20px';
                    hotbarContainer.style.left = '50%';
                    hotbarContainer.style.transform = 'translateX(-50%)';
                    hotbarContainer.style.display = 'flex';
                    hotbarContainer.style.gap = '5px';
                    hotbarContainer.style.padding = '10px';
                    hotbarContainer.style.background = 'rgba(0, 0, 0, 0.5)';
                    hotbarContainer.style.borderRadius = '5px';
                    
                    const hotbar = document.createElement('div');
                    hotbar.id = 'hotbar';
                    hotbar.style.display = 'flex';
                    hotbar.style.gap = '5px';
                    hotbarContainer.appendChild(hotbar);
                    document.body.appendChild(hotbarContainer);
                    
                    // Update inventory with some default items
                    updateInventoryUI();
                    
                    // Close inventory button
                    document.getElementById('close-inventory').addEventListener('click', () => {
                        document.getElementById('inventory-container').style.display = 'none';
                    });
                }
            }

            // Update inventory UI
            function updateInventoryUI() {
                // Create inventory slots
                const inventoryGrid = document.getElementById('inventory-grid');
                if (inventoryGrid) {
                    inventoryGrid.innerHTML = '';
                    for (let i = 0; i < 36; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'inventory-slot';
                        slot.dataset.slot = i;
                        inventoryGrid.appendChild(slot);
                    }
                }
                
                // Create hotbar slots with default blocks
                const hotbar = document.getElementById('hotbar');
                if (hotbar) {
                    hotbar.innerHTML = '';
                    
                    // Default block types for hotbar
                    const hotbarBlocks = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'water', 'brick', 'snow'];
                    
                    for (let i = 0; i < 9; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'hotbar-slot';
                        if (i === 0) {
                            slot.classList.add('selected');
                            selectedBlock = hotbarBlocks[i];
                        }
                        slot.dataset.slot = i;
                        slot.dataset.block = hotbarBlocks[i];
                        
                        // Add block icon
                        const blockIcon = document.createElement('div');
                        blockIcon.style.width = '80%';
                        blockIcon.style.height = '80%';
                        blockIcon.style.margin = '10%';
                        blockIcon.style.backgroundColor = blockMaterials[hotbarBlocks[i]].color.toString(16);
                        slot.appendChild(blockIcon);
                        
                        // Add click event to select block
                        slot.addEventListener('click', (e) => {
                            e.stopPropagation();
                            document.querySelectorAll('.hotbar-slot').forEach(s => s.classList.remove('selected'));
                            slot.classList.add('selected');
                            selectedBlock = slot.dataset.block;
                            console.log('Selected block:', selectedBlock);
                        });
                        
                        hotbar.appendChild(slot);
                    }
                }
            }

            // Add number key controls for hotbar selection
            document.addEventListener('keydown', (e) => {
                const keyNum = parseInt(e.key);
                if (!isNaN(keyNum) && keyNum >= 1 && keyNum <= 9) {
                    const index = keyNum - 1;
                    const slots = document.querySelectorAll('.hotbar-slot');
                    if (slots[index]) {
                        slots.forEach(s => s.classList.remove('selected'));
                        slots[index].classList.add('selected');
                        selectedBlock = slots[index].dataset.block;
                        console.log('Selected block:', selectedBlock);
                    }
                }
            });

            // Add biome indicator to UI
            const biomeIndicator = document.createElement('div');
            biomeIndicator.id = 'biome-indicator';
            biomeIndicator.style.position = 'fixed';
            biomeIndicator.style.top = '40px';
            biomeIndicator.style.left = '10px';
            biomeIndicator.style.padding = '5px 10px';
            biomeIndicator.style.background = 'rgba(0, 0, 0, 0.5)';
            biomeIndicator.style.color = 'white';
            biomeIndicator.style.borderRadius = '5px';
            document.body.appendChild(biomeIndicator);
            biomeIndicator.textContent = 'Biome: Loading...';

            // Initialize weather function variable before use in animate
            let weatherUpdateFunction = () => {}; // Empty function as placeholder

            // Update animation loop with weather particles
            function animate() {
                requestAnimationFrame(animate);
                
                // Debug frame counter
                if (frameCount === undefined) {
                    frameCount = 0;
                }
                if (frameCount % 60 === 0) {
                    console.log('Frame:', frameCount, 'Camera position:', camera.position);
                }
                frameCount++;
                
                // Update physics and controls
                if (isPointerLocked) {
                    const moveVector = new THREE.Vector3();
                    if (keys['KeyW']) moveVector.z -= moveSpeed;
                    if (keys['KeyS']) moveVector.z += moveSpeed;
                    if (keys['KeyA']) moveVector.x -= moveSpeed;
                    if (keys['KeyD']) moveVector.x += moveSpeed;
                    if (keys['Space']) moveVector.y += moveSpeed;
                    if (keys['ShiftLeft']) moveVector.y -= moveSpeed;
                    
                    // Rotate move vector by camera rotation
                    moveVector.applyQuaternion(camera.quaternion);
                    camera.position.add(moveVector);
                }
                
                // Update day/night cycle
                updateDayNight();
                
                // Update night objects visibility
                updateNightObjects();
                
                // Update lighting based on time of day
                updateLighting();
                
                // Update weather particles
                if (weatherUpdateFunction) {
                    weatherUpdateFunction();
                }
                
                // Update weather sounds
                updateWeatherSounds();
                
                // Update biome indicator
                updateBiomeIndicator();
                
                // Render the scene
                try {
                    renderer.render(scene, camera);
                    if (frameCount % 60 === 0) {
                        console.log('Render successful', frameCount);
                    }
                } catch (error) {
                    console.error('Render error:', error);
                }
            }

            // Initialize day/night cycle
            initDayNight();
            
            // Initialize inventory
            initializeInventory();
            
            // Start animation
            console.log('Starting animation loop');
            animate();
            console.log('Animation loop started');
            
            // Add a visible message on the canvas to confirm rendering
            addChatMessage('Game world initialized! If you see a white screen, check console for errors.', 'system-message');

            // Add event listeners for settings button
            document.getElementById('settings-button').addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event bubbling to the document
                document.getElementById('game-settings').classList.toggle('visible');
            });

            // Prevent pointer lock when clicking on UI elements
            document.querySelectorAll('#ui-container, #game-settings').forEach(element => {
                element.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent the click from bubbling to document
                });
            });

            // Generate terrain
            function generateTerrain() {
                const blocks = {};
                const chunkSize = CHUNK_SIZE;
                const heightScale = 10;
                const noiseScale = 0.05;
                
                for (let x = -chunkSize; x < chunkSize; x++) {
                    for (let z = -chunkSize; z < chunkSize; z++) {
                        // Get biome
                        const biome = getBiome(x, z);
                        
                        // Generate height based on noise
                        const noise = simplex.noise2D(x * noiseScale, z * noiseScale);
                        let height = Math.floor((noise + 1) * heightScale);
                        
                        // Adjust height based on biome
                        if (biome === 'Mountains') {
                            height += 5;
                        } else if (biome === 'Snowy Mountains') {
                            height += 8;
                        } else if (biome === 'Beach') {
                            height = 1;
                        }
                        
                        // Add blocks at different heights
                        for (let y = 0; y <= height; y++) {
                            const positionKey = `${x},${y},${z}`;
                            let blockType = 'dirt';
                            
                            // Top layer
                            if (y === height) {
                                if (biome === 'Desert') {
                                    blockType = 'sand';
                                } else if (biome === 'Beach') {
                                    blockType = 'sand';
                                } else if (biome === 'Snowy Mountains' && height > 10) {
                                    blockType = 'snow';
                                } else {
                                    blockType = 'grass';
                                }
                            } 
                            // Bottom layer
                            else if (y < height - 3) {
                                blockType = 'stone';
                            }
                            
                            // Add water for low areas
                            if (y <= 1 && blockType !== 'sand') {
                                blockType = 'water';
                            }
                            
                            blocks[positionKey] = { type: blockType };
                        }
                        
                        // Add trees randomly in forest biomes
                        if (biome === 'Forest' && Math.random() < 0.1) {
                            const treeHeight = 4 + Math.floor(Math.random() * 3);
                            // Tree trunk
                            for (let y = height + 1; y < height + treeHeight; y++) {
                                blocks[`${x},${y},${z}`] = { type: 'wood' };
                            }
                            // Tree leaves
                            for (let lx = -2; lx <= 2; lx++) {
                                for (let ly = 0; ly <= 2; ly++) {
                                    for (let lz = -2; lz <= 2; lz++) {
                                        const leafX = x + lx;
                                        const leafY = height + treeHeight + ly;
                                        const leafZ = z + lz;
                                        if (Math.random() < 0.7 && Math.abs(lx) + Math.abs(ly) + Math.abs(lz) < 5) {
                                            blocks[`${leafX},${leafY},${leafZ}`] = { type: 'leaves' };
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log(`Generated terrain with ${Object.keys(blocks).length} blocks`);
                return blocks;
            }
            
            // Initialize the world with terrain
            let initialBlocks = generateTerrain();
            updateWorld(initialBlocks);

            // Weather system
            const weatherTypes = {
                clear: { type: 'clear', particleCount: 0, color: 0xffffff },
                rain: { type: 'rain', particleCount: 1000, color: 0x99ccff },
                snow: { type: 'snow', particleCount: 500, color: 0xffffff }
            };
            
            let weatherParticles = [];
            
            function createWeatherParticles(weatherType) {
                // Remove old particles
                weatherParticles.forEach(particle => {
                    scene.remove(particle);
                });
                weatherParticles = [];
                
                if (weatherType === 'clear') return;
                
                const weather = weatherTypes[weatherType];
                const particleGeometry = new THREE.BufferGeometry();
                const particlePositions = [];
                
                // Create particles in a box above the player
                for (let i = 0; i < weather.particleCount; i++) {
                    const x = Math.random() * 100 - 50;
                    const y = Math.random() * 20 + 20;
                    const z = Math.random() * 100 - 50;
                    particlePositions.push(x, y, z);
                }
                
                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
                
                // Create material based on weather type
                const particleMaterial = new THREE.PointsMaterial({
                    color: weather.color,
                    size: weatherType === 'rain' ? 0.1 : 0.3,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);
                weatherParticles.push(particles);
                
                // Add particle animation to animate function
                const updateWeatherParticles = () => {
                    const positions = particleGeometry.attributes.position.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // Move particles down
                        positions[i + 1] -= weatherType === 'rain' ? 0.2 : 0.05;
                        
                        // If snow, add some horizontal movement
                        if (weatherType === 'snow') {
                            positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                            positions[i + 2] += Math.cos(Date.now() * 0.001 + i) * 0.01;
                        }
                        
                        // Reset particles that go below ground
                        if (positions[i + 1] < 0) {
                            positions[i] = Math.random() * 100 - 50 + camera.position.x;
                            positions[i + 1] = Math.random() * 20 + 20;
                            positions[i + 2] = Math.random() * 100 - 50 + camera.position.z;
                        }
                    }
                    
                    particleGeometry.attributes.position.needsUpdate = true;
                };
                
                return updateWeatherParticles;
            }
            
            // Function to change weather
            function changeWeather() {
                // Get the biome at the player's position
                const biome = getBiome(camera.position.x, camera.position.z);
                
                // Set weather based on biome and random chance
                const chance = Math.random();
                if (biome === 'Snowy Mountains') {
                    currentWeather = chance < 0.7 ? 'snow' : 'clear';
                } else if (biome === 'Mountains' || biome === 'Forest') {
                    currentWeather = chance < 0.3 ? 'rain' : 'clear';
                } else if (biome === 'Plains') {
                    currentWeather = chance < 0.2 ? 'rain' : 'clear';
                } else if (biome === 'Desert') {
                    currentWeather = 'clear';
                } else {
                    currentWeather = chance < 0.1 ? 'rain' : 'clear';
                }
                
                // Create weather particles
                weatherUpdateFunction = createWeatherParticles(currentWeather);
                
                // Show weather message
                addChatMessage(`Weather changed to ${currentWeather}!`, 'system-message');
                
                // Schedule next weather change
                setTimeout(changeWeather, 30000 + Math.random() * 60000);
            }
            
            // Initialize weather
            changeWeather();
        });
    </script>
</body>
</html> 